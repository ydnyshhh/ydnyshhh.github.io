<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Beyond PPO - The New Wave of Policy Optimization for LLM Post-Training | yadnyesh&#39;s blog</title>
<meta name="keywords" content="post-training, RLHF, policy optimization, reinforcement learning">
<meta name="description" content="PPO used to be the default workhorse for RLHF because it’s reasonably stable and easy to reason about, but at LLM post-training scale its tradeoffs start to bite: the critic/value model is expensive to train and maintain, long text rollouts amplify variance and make advantage estimation brittle, clipping becomes a blunt instrument that can under-update (wasting samples) or over-update (destabilizing), and the whole loop turns into a systems-heavy exercise once “environment interaction” means generating thousands of tokens across distributed inference. As post-training shifted from short preference tuning toward reasoning-heavy objectives (RLVR, long-CoT, verifier-driven rewards, pass@k-style targets) and larger, more heterogeneous data mixtures, these weaknesses became harder to paper over with hyperparameter folklore because the optimization problem is noisier, the feedback signals are sparser, and the failure modes (reward hacking, length bias, mode collapse, over-regularization) are more punishing. That’s why the field has been moving beyond “just PPO” toward more robust, more LLM-native policy optimization: methods that reduce dependence on a critic, stabilize updates under long-horizon generation, better control distribution shift between samples and policy, and align the training objective with how we actually evaluate modern models, ultimately making post-training not just possible, but reliable under the messy realities of large-scale reasoning optimization.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/policy_optimization/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css" integrity="sha256-bammPSWpYIvKL3&#43;QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/policy_optimization/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  });">
</script>


</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="yadnyesh&#39;s blog (Alt + H)">yadnyesh&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/readinglist/" title="Reading List">
                    <span>Reading List</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Beyond PPO - The New Wave of Policy Optimization for LLM Post-Training
    </h1>
    <div class="post-meta"><span title='2025-12-28 12:23:11 +0530 IST'>December 28, 2025</span>&nbsp;·&nbsp;58 min

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#1-from-ppo-to-grpo" aria-label="1) From PPO to GRPO">1) From PPO to GRPO</a></li>
                <li>
                    <a href="#2-grpo-group-relative-policy-optimization-grpo" aria-label="2) GRPO: Group Relative Policy Optimization (GRPO)">2) GRPO: Group Relative Policy Optimization (GRPO)</a></li>
                <li>
                    <a href="#key-changes-vs-ppo" aria-label="Key changes vs PPO">Key changes vs PPO</a></li>
                <li>
                    <a href="#3-drgrpo-grpo-done-right" aria-label="3) DR.GRPO (GRPO done Right)">3) DR.GRPO (GRPO done Right)</a></li>
                <li>
                    <a href="#4-gspo-group-sequence-policy-optimization" aria-label="4) GSPO (Group Sequence Policy Optimization)">4) GSPO (Group Sequence Policy Optimization)</a></li>
                <li>
                    <a href="#5-decoupled-clip-and-dynamic-sampling-policy-optimization-dapo" aria-label="5) Decoupled Clip and Dynamic Sampling Policy Optimization (DAPO)">5) Decoupled Clip and Dynamic Sampling Policy Optimization (DAPO)</a></li>
                <li>
                    <a href="#6-cispo-clipped-is-weight-policy-optimization" aria-label="6) CISPO (Clipped IS-weight Policy Optimization)">6) CISPO (Clipped IS-weight Policy Optimization)</a></li>
                <li>
                    <a href="#7-geometric-mean-policy-optimization-gmpo" aria-label="7) Geometric Mean Policy Optimization (GMPO)">7) Geometric Mean Policy Optimization (GMPO)</a></li>
                <li>
                    <a href="#8-router-shift-policy-optimization-rspo" aria-label="8) Router-Shift Policy Optimization (RSPO)">8) Router-Shift Policy Optimization (RSPO)</a></li>
                <li>
                    <a href="#9-soft-adaptive-policy-optimization-sapo" aria-label="9) Soft Adaptive Policy Optimization (SAPO)">9) Soft Adaptive Policy Optimization (SAPO)</a></li></ul>
                    
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>PPO used to be the default workhorse for RLHF because it’s reasonably stable and easy to reason about, but at LLM post-training scale its tradeoffs start to bite: the critic/value model is expensive to train and maintain, long text rollouts amplify variance and make advantage estimation brittle, clipping becomes a blunt instrument that can under-update (wasting samples) or over-update (destabilizing), and the whole loop turns into a systems-heavy exercise once “environment interaction” means generating thousands of tokens across distributed inference. As post-training shifted from short preference tuning toward <strong>reasoning-heavy objectives</strong> (RLVR, long-CoT, verifier-driven rewards, pass@k-style targets) and larger, more heterogeneous data mixtures, these weaknesses became harder to paper over with hyperparameter folklore because the optimization problem is noisier, the feedback signals are sparser, and the failure modes (reward hacking, length bias, mode collapse, over-regularization) are more punishing. That’s why the field has been moving beyond “just PPO” toward <strong>more robust, more LLM-native policy optimization</strong>: methods that reduce dependence on a critic, stabilize updates under long-horizon generation, better control distribution shift between samples and policy, and align the training objective with how we actually evaluate modern models, ultimately making post-training not just <em>possible</em>, but <em>reliable</em> under the messy realities of large-scale reasoning optimization.</p>
<h3 id="1-from-ppo-to-grpo">1) From PPO to GRPO<a hidden class="anchor" aria-hidden="true" href="#1-from-ppo-to-grpo">#</a></h3>
<p><a href="https://arxiv.org/abs/1707.06347">Proximal Policy Optimization (PPO)</a> is the standard “safe policy gradient” workhorse: you collect trajectories using an <strong>old</strong> policy $\pi_{\theta_{\text{old}}}$​​, then update a <strong>new</strong> policy $\pi_\theta$ to make good actions more likely and bad actions less likely <em>but only by a limited amount per update</em> so training doesn’t blow up. The core trick is the <strong>importance ratio</strong>:</p>
<p>$$
r_t(\theta)=\frac{\pi_\theta(a_t|s_t)}{\pi_{\theta_{\text{old}}}(a_t|s_t)}
$$</p>
<p>which measures how much the new policy changes the probability of the sampled action $a_t$​ in state $s_t$, PPO multiplies this by an <strong>advantage</strong> $\hat A_t$​ (how much better that action was than expected, typically estimated using a learned <strong>value function</strong>/critic $V_Φ$​ via <a href="https://nn.labml.ai/rl/ppo/gae.html">GAE</a>) and optimizes a <strong>clipped surrogate</strong>:</p>
<p>$$
L^{\text{CLIP}}(\theta) = \mathbb{E}_t\left[\min\big(r_t\hat A_t, \text{clip}(r_t,1-\epsilon,1+\epsilon)\hat A_t\big)\right]
$$</p>
<p>where the clip parameter $\epsilon$ enforces “don’t move the policy too far” (a trust-region-lite constraint). In practice you train with a combined objective: maximize the clipped policy term, plus a value regression loss $\mathbb{E}_t [(V_Φ)(s_t)-\hat V_t)^2]$ to keep $\hat A_t$ low-variance, and often an entropy bonus to avoid collapse. The <strong>full loss</strong> optimized in practice (<a href="https://sebastianraschka.com/faq/docs/gradient-optimization.html">gradient descent</a>) is typically written as:</p>
<p>$$
\mathcal{L}(\theta, Φ)= -L^{\text{CLIP}}(\theta) + c_v \mathbb{E}_t\left[\big(V_Φ(s_t)-\hat V_t\big)^2\right] - c_e \mathbb{E}_t [H (\pi_θ(\cdot\mid s_t)]
$$</p>
<p>where:</p>
<ul>
<li>the first term is the (negative) policy objective,</li>
<li>the second is the value/critic regression loss,</li>
<li>the third is an entropy bonus (encourages exploration / prevents collapse)</li>
<li>$c_v,  c_e$ are coefficients.</li>
</ul>
<p>In <a href="https://en.wikipedia.org/wiki/Reinforcement_learning_from_human_feedback">RLHF</a>, you usually also keep the policy close to a reference model $\pi_{\text{ref}}$. Often this is implemented as:</p>
<ul>
<li>either a <a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">KL</a> penalty in reward (per token),</li>
<li>or an explicit term in the objective.</li>
</ul>
<p>A common explicit version:
$$
\mathbb{E}_t [β D _ {\text{KL}} (\pi_θ(\cdot\mid s_t) || \pi _ {\text{ref}}(\cdot\mid s_t))]
$$</p>
<p>added to the loss (penalizing deviation from reference).</p>
<p>So PPO is essentially <em>policy gradient + baseline + a hard brake on update size</em> to keep learning stable.</p>
<p>PPO became the “default RLHF optimizer” mostly because it’s a pragmatic compromise: it gives you a <em>trust-region-ish</em> update without the full <a href="https://spinningup.openai.com/en/latest/algorithms/trpo.html">TRPO</a> machinery, and it’s reasonably stable when your policy gradient estimates are noisy. In LLM post-training, though, PPO inherits two pain points that get worse exactly when you care the most (reasoning + long rollouts): <strong>(1) the critic tax</strong> and <strong>(2) mismatch between token-level machinery and sequence-level rewards</strong>. <a href="https://arxiv.org/abs/2402.03300">DeepSeekMath</a> spells this out bluntly: PPO requires training a value function baseline, which is typically a model comparable in size to the policy, adding substantial memory/compute burden; and in the LLM setting the reward model often assigns a score only at the end, which makes it awkward to train a value function “accurate at each token.”</p>
<p>Let’s make the failure mode concrete. PPO’s core surrogate objective (token-level importance ratios with clipping) looks like: you sample an output $o$ from the <em>old</em> policy $\pi_{\theta_{\text{old}}}$, compute per-token advantages $A_t$ (often via GAE + a learned value $V_\psi$​), and optimize a clipped objective to avoid large policy updates.</p>
<p>In “classic RL,” learning a critic is annoying but manageable. In RLHF-for-LLMs, it becomes a constant tax:</p>
<ul>
<li><strong>You’re basically training an extra LLM</strong> (the value model) plus keeping the reference model and reward model around.</li>
<li><strong>Your reward is often sparse / end-of-sequence</strong>, but PPO wants token-level advantages; you end up backfilling credit assignment with heuristics (GAE, reward shaping, KL-in-reward, etc.) and now your “algorithm” is half math, half duct tape. DeepSeekMath explicitly notes this tension between end-of-sequence reward scoring and token-wise value modeling.</li>
<li><strong>As sequences get longer</strong>, variance rises and the “clip knob” becomes a vibe-based tuning exercise.</li>
</ul>
<h3 id="2-grpo-group-relative-policy-optimization-grpo">2) GRPO: Group Relative Policy Optimization (GRPO)<a hidden class="anchor" aria-hidden="true" href="#2-grpo-group-relative-policy-optimization-grpo">#</a></h3>
<p>GRPO keeps the spirit of PPO (importance ratios + clipping + KL regularization), but it swaps out the value function baseline with something you can compute <em>for free</em> from sampling: <strong>generate G completions for the same prompt, score them, and use the group’s average as the baseline.</strong> <a href="https://arxiv.org/abs/2402.03300">DeepSeekMath</a> frames GRPO as “obviating the need for additional value function approximation” and instead using “the average reward of multiple sampled outputs…as the baseline.” That one swap has huge downstream effects:</p>
<ul>
<li>No critic model to train.</li>
<li>Advantage estimation becomes <em>within-prompt, relative</em>, matching how preference/reward models are often trained (comparisons among outputs for the same question). DeepSeekMath makes this alignment argument explicitly.</li>
</ul>
<p>DeepSeekMath defines a GRPO objective that still looks PPO-like: for each prompt $q$, sample a group $ {o_i} _ {i=1}^G$​ from $ \pi _ {\theta _ {\text{old}}}$​​, then optimize a clipped surrogate over tokens, plus a KL term to a reference policy. <a href="https://arxiv.org/abs/2501.12948">DeepSeek-R1</a>’s report gives a clean, readable version of the same idea at the <strong>sequence level</strong>:</p>
<p>$$
J _ { \text{GRPO} } ( \theta ) = \mathbb{E} _ { q \sim \mathcal{D} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) }
$$</p>
<p>$$
[ \frac{1}{G} \sum _ { i = 1 } ^ G \min ( r _ i ( \theta ) A _ i , \text{clip} ( r _ i ( \theta ) , 1 - \epsilon , 1 + \epsilon ) A _ i ) - \beta \mathbb{D} _ { \text{KL} } ( \pi _ \theta ( \cdot | q ) || \pi _ { \text{ref} } ( \cdot | q ) ) ]
$$</p>
<p>where:</p>
<p>$$
\underbrace{ \frac{1}{ \color{purple}{G} } \sum _ { i = 1 } ^ { \color{purple}{G} } } _ { \color{purple}{ \text{Group size } G } }
( \min (
\underbrace{ \color{blue}{ \frac{ \pi _ \theta ( o _ i | q ) }{ \pi _ { \theta _ { \text{old} } } ( o _ i | q ) } } } _ { \color{blue}{ \text{probability ratio} } }
\underbrace{ \color{magenta}{ A _ i } } _ { \color{magenta}{ \text{advantage} } } ,
\underbrace{ \color{red}{ \text{clip} ( \color{blue}{ \frac{ \pi _ \theta ( o _ i | q ) }{ \pi _ { \theta _ { \text{old} } } ( o _ i | q ) } } , 1 - \epsilon , 1 + \epsilon ) } } _ { \color{red}{ \text {clipping keeps ratio in }[1-\epsilon,1+\epsilon] } }
\underbrace{ \color{magenta}{ A _ i } } _ { \color{magenta}{ \text{advantage} } } ) -
\underbrace{ \color{orange}{ \beta \mathbb{D} _ { \text{KL} } ( \pi _ \theta || \pi _ { \text{ref} } ) } } _ { \color{orange}{ \text{KL penalty} } } )
$$</p>
<p>$$
\color{purple}{ \epsilon , \beta \text{ are hyperparameters.} }
$$</p>
<p>$$
\color{magenta}{ A _ i } = \frac{ \color{magenta}{ r _ i } - \text{mean} ( { \color{magenta}{ r _ 1 } , \color{magenta}{ r _ 2 } , \dots , \color{magenta}{ r _ G } } ) }{ \text{std} ( { \color{magenta}{ r _ 1 } , \color{magenta}{ r _ 2 } , \dots , \color{magenta}{ r _ G } } ) }
$$</p>
<p>$$
\color{magenta}{ \text{(how much better/worse } o _ i \text{ is vs the group baseline).} }
$$</p>
<p><strong>GRPO turns advantage estimation into a local ranking problem.</strong> Each prompt produces a small batch of candidates; the <a href="https://cameronrwolfe.substack.com/p/reward-models">reward model</a> (or verifier) scores them; and the policy update says “increase probability of better-than-average completions, decrease probability of worse-than-average ones,” while clipping prevents the model from overreacting to a noisy batch.</p>
<p>Let&rsquo;s understand some of the key terms from the above objective function:</p>
<ol>
<li>
<p><strong>The Importance Weight:</strong>
A key ingredient in GRPO is the <strong>importance weight</strong>: a per-token quantity that tells us how much the <em>current</em> policy has changed its mind compared to the <em>old</em> policy. Intuitively, it answers: “Is token $o_{i,t}$​ more likely or less likely under the updated model than it was when we generated the sample?” This matters because GRPO (like PPO) learns from data generated by an earlier snapshot of the policy, so we need a way to correct for that mismatch. Formally, consider the $t$-th token of the $i$-th sampled completion, $o_{i,t}$​. The token is conditioned on the prompt $q$ and the previously generated tokens $o_{i,&lt;t}$​. The importance weight is the ratio of the token’s probability under the current policy $\pi_\theta$​ to its probability under the old policy $\pi_{\theta_{\text{old}}}$​​:</p>
<p>$$
w_{i,t}(\theta)=\frac{\pi_\theta \left(o_{i,t}\mid q, o_{i,&lt;t}\right)}{\pi_{\theta_{\text{old}}} \left(o_{i,t}\mid q ,o_{i,&lt;t}\right)}.
$$</p>
<p>If $w_{i,t}(\theta) &gt; 1$, the new policy assigns <strong>higher</strong> probability to that token than the old policy did; if $w_{i,t}(\theta) &lt; 1$, it assigns <strong>lower</strong> probability. In other words, this ratio is a direct measure of how strongly the update is pushing the model toward (or away from) specific token choices within a generated answer.</p>
</li>
<li>
<p><strong>The Advantage Term $A_i$:</strong>
Once GRPO has a group of $G$ sampled completions for the same prompt $q$, it needs a learning signal that says <strong>which samples are worth reinforcing</strong>. That’s what the <strong>advantage</strong> $A_i$ does: it measures how much better (or worse) a particular completion $o_i$is <strong>relative to the other completions in the same group</strong>. Think of it as a tiny “local ranking” step: for a given question, you generate multiple answers, score them with a reward signal (reward model / verifier / rule-based checker), and then ask: <em>“Is this answer above average for this prompt?”</em> If yes, $A_i$​ is positive and GRPO increases its probability; if no, $A_i$​ is negative and GRPO suppresses it. This is the core GRPO trick: <strong>you get a baseline for free from the group itself</strong>, instead of training a separate critic/value model like PPO. In practice, GRPO typically uses a <strong>normalized, group-centered reward</strong>:</p>
<p>$$
A _ i = \frac{ R _ i - \text{mean} ( { R _ 1 , R _ 2 , \dots , R _ G } ) }{ \text{std} ( { R _ 1 , R _ 2 , \dots , R _ G } ) }
$$</p>
<p>where:
i) $R_i$​ - is the reward score for completion $o_i$​.
ii) $\operatorname{mean}(⋅)$ - is the average reward across the group (the baseline).
iii) $\operatorname{std}(⋅)$ - rescales by the group’s spread, making updates less sensitive to the absolute scale of rewards.</p>
</li>
<li>
<p><strong>The Clipping Term:</strong>
GRPO borrows PPO’s most important stability trick: <strong>clipping the importance ratio</strong> so each update stays <em>proximal</em> to the policy that generated the samples. Without clipping, the optimizer can “overreact” to a high-reward sample by massively increasing its probability in a single step, especially when rewards are noisy (which they often are in LLM post-training). The object being clipped is the <strong>importance ratio</strong> (sequence-level or token-level). Clipping forces it into a tight band around 1:
$$
\text{clip} ( r ( \theta ) , 1 - \epsilon , 1 + \epsilon )
$$</p>
</li>
</ol>
<h3 id="key-changes-vs-ppo">Key changes vs PPO<a hidden class="anchor" aria-hidden="true" href="#key-changes-vs-ppo">#</a></h3>
<ol>
<li><strong>Critic-free baseline:</strong> PPO’s $A_t$​ comes from GAE + value model; GRPO’s advantage comes from the group’s relative scores. This is the resource and complexity win DeepSeekMath emphasizes.</li>
<li><strong>Relative (within-prompt) learning signal:</strong> Instead of asking for an absolute, token-wise value prediction, you use “how did this completion do compared to siblings for the same prompt,” which is closer to how reward models are trained (pairwise comparisons).</li>
<li><strong>KL handling becomes cleaner:</strong> DeepSeekMath notes that rather than folding KL into the reward (per-token KL penalty inside $r_t$​ in PPO-style RLHF), GRPO adds KL divergence directly to the loss, which avoids complicating advantage calculation.</li>
</ol>
<h3 id="3-drgrpo-grpo-done-right">3) DR.GRPO (GRPO done Right)<a hidden class="anchor" aria-hidden="true" href="#3-drgrpo-grpo-done-right">#</a></h3>
<p>GRPO is a big step up from PPO in practice, but its <em>default</em> objective quietly smuggles in biases:</p>
<ol>
<li>
<p><strong>Baseline bias (group mean scaling):</strong> In GRPO, the advantage is built by subtracting a <em>group baseline</em>, typically the average reward (or score) over the $G$ sampled completions for the same prompt. The subtle issue is that if you treat the group mean as the baseline for each sample, the “right” way to scale that baseline is tied to the fact that each sample is being compared against the <em>other $G-1$ samples</em>, not against a population mean. Using a naive $\frac{1}{G}$​ scaling instead of the correct $\frac{1}{G-1}$ style correction introduces a small but systematic mis-scaling of the advantage, which means the GRPO gradient is <em>biased</em> even before clipping or KL come into play.</p>
</li>
<li>
<p><strong>Response-level length bias ($\mathbf{1/|o_i|}$ factor):</strong> Many GRPO implementations average the token-level surrogate by response length via a factor $\frac{1}{|o_i|}\sum_{t}\cdots$. In the GRPO objective, that turns the same sequence-level advantage into a <strong>per-token learning rate that depends on how long the model chose to talk</strong>. The consequence is asymmetric: for <strong>positive</strong> advantage samples (usually correct/high-reward answers), the update is stronger when the response is shorter (reward is concentrated into fewer tokens), so GRPO implicitly prefers short correct answers; for <strong>negative</strong> advantage samples (often incorrect answers), the penalty is diluted when the response is longer, so the model can “hide” badness by generating more tokens. This is exactly the “short correct, long wrong” failure pattern that motivates Dr. GRPO.</p>
</li>
<li>
<p><strong>Question-level difficulty bias (std-normalized advantages):</strong> GRPO often normalizes advantages within each prompt’s group, e.g. $\hat A_i = \frac{R_i-\text{mean}(R)}{\text{std}(R)}$​. That sounds like harmless variance reduction, but in the GRPO objective it effectively <strong>reweights prompts</strong> based on their within-group reward spread. Since different prompts vary widely in domain and difficulty (LLM post-training is effectively multi-task RL), prompts with <strong>low</strong> reward variance (often very easy or very hard prompts where all sampled answers score similarly) get their gradients <strong>amplified</strong> by dividing by a small std, while prompts with higher variance get damped. This distorts the learning signal across prompts: instead of naturally focusing on medium-difficulty questions (where learning is most productive), the std term can unintentionally upweight easy and impossible prompts, pushing GRPO’s optimization in a less efficient direction.</p>
</li>
</ol>
<p>For the baseline-bias issue, the mismatch is essentially just a constant rescaling of the gradient, which you can fold into the effective learning rate. And since practitioners tune the learning rate anyway, this particular bias typically has little to no noticeable impact on final training performance. For the other two biases, <a href="https://arxiv.org/abs/2503.20783">Group Relative Policy Optimization Done Right (Dr. GRPO)</a> addresses them by simply removing $1/∣o∣$ and $std⁡[r_k]$:</p>
<p>$$
\textbf{GRPO}
$$</p>
<p>$$
\qquad \frac{1}{G} \sum _ { i = 1 } ^ G {\color{red}{ \frac{1}{ | o _ i | } }} \sum _ { t = 1 } ^ { | o _ i | } { \min [ \frac{ \pi _ \theta ( o _ { i,t } | q , o _ { i,&lt;t } ) }{ \pi _ { \theta _ { \text{old} } } ( o _ { i,t } | q , o _ { i,&lt;t } ) } \hat{A} _ { i,t } , \text{clip} ( \frac{ \pi _ \theta ( o _ { i,t } | q , o _ { i,&lt;t } ) }{ \pi _ { \theta _ { \text{old} } } ( o _ { i,t } | q , o _ { i,&lt;t } ) } , 1 - \epsilon , 1 + \epsilon ) \hat{A} _ { i,t } ] }
$$</p>
<p>$$
\text{where} \quad \hat{A} _ { i,t } = \frac{ R ( q , o _ i ) - \text{mean} ( { R ( q , o _ 1 ) , \dots , R ( q , o _ G ) } ) }{ \color{red}{ \text{std} ( { R ( q , o _ 1 ) , \dots , R ( q , o _ G ) } ) } }
$$</p>
<p>$$
\textbf{Dr. GRPO} \quad \text{(GRPO Done Right, without bias)}
$$</p>
<p>$$
\qquad \frac{1}{G} \sum _ { i = 1 } ^ G \sum _ { t = 1 } ^ { | o _ i | } { \min [ \frac{ \pi _ \theta ( o _ { i,t } | q , o _ { i, &lt;t } ) }{ \pi _ { \theta _ { \text{old} } } ( o _ { i,t } | q , o _ { i, &lt;t } ) } \hat{A} _ { i,t } , \text{clip} ( \frac{ \pi _ \theta ( o _ { i,t } | q , o _ { i, &lt;t } ) }{ \pi _ { \theta _ { \text{old} } } ( o _ { i,t } | q , o _ { i, &lt;t } ) } , 1 - \epsilon , 1 + \epsilon ) \hat{A} _ { i,t } ] }
$$</p>
<p>$$
\text{where} \quad \hat{A} _ { i,t } = R ( q , o _ i ) - \text{mean} ( { R ( q , o _ 1 ) , \dots , R ( q , o _ G ) } )
$$</p>
<p>By correcting these mathematical inconsistencies, Dr. GRPO prevents the &ldquo;<strong>double-increase</strong>&rdquo; phenomenon where response lengths grow uncontrollably, enhances <strong>token efficiency</strong>, and reduces the tendency for &ldquo;overthinking&rdquo; in incorrect responses while consistently achieving superior accuracy and training stability compared to vanilla GRPO.</p>
<h3 id="4-gspo-group-sequence-policy-optimization">4) GSPO (Group Sequence Policy Optimization)<a hidden class="anchor" aria-hidden="true" href="#4-gspo-group-sequence-policy-optimization">#</a></h3>
<p>GRPO inherits PPO’s off-policy correction instinct, but it pushes it down to the <strong>token level</strong>: every next-token decision gets its own <strong>importance-sampling ratio</strong>, even though we only observed <strong>one</strong> sample from that conditional distribution. In proper IS, the ratio earns its keep by averaging over many samples from the behavior policy; here, the “correction” mostly acts like a noisy multiplicative weight on the gradient. The GSPO authors argue this is the wrong granularity for LLM post-training: the variance from token-wise ratios <strong>compounds across long responses</strong>, and once you add clipping on top, you can end up amplifying the worst kinds of noise, creating training dynamics that don’t just wobble, but can <strong>collapse catastrophically</strong> and sometimes never recover.</p>
<p><a href="https://arxiv.org/abs/2507.18071">Group Sequence Policy Optimization (GSPO)</a> is essentially a “unit fix”: it moves the core optimization step from <strong>tokens</strong> to <strong>sequences</strong>, and that shift is what buys stability. The motivation is straightforward, prior group-based methods like GRPO can become unstable on long-reasoning, large-scale training, sometimes spiraling into a collapse that doesn’t recover. GSPO tackles this in a few concrete ways.</p>
<p>First, it corrects what the authors describe as a misuse of importance sampling in GRPO: GRPO applies an IS-style weight at every token position, but that weight is computed from a single sampled token, which doesn’t serve the variance-reduction role IS is supposed to play; instead it injects noisy multiplicative factors into the gradient and that noise compounds with response length. GSPO replaces this with a <strong>sequence-level importance ratio</strong> $s_i$​ based on whole-sequence likelihood, matching the fact that the reward signal is typically assigned to the entire completion, not individual tokens.</p>
<p>Second, the gradient structure becomes much cleaner: GRPO effectively reweights tokens unequally via token-level ratios $w_{i,t}$​, which can swing wildly and destabilize updates; GSPO gives all tokens in a response equal weight and applies the correction once per sequence, removing a major source of jitter.</p>
<p>Third, this matters a lot for <a href="https://cameronrwolfe.substack.com/p/conditional-computation-the-birth">Mixture-of-Experts: MoE</a> routing can change sharply after a single update, making token-level ratios extremely volatile (and forcing hacks like “routing replay” in GRPO-style training), whereas sequence likelihood remains comparatively stable even when internal expert choices shift, so GSPO can train MoE models without those artificial constraints. Finally, GSPO clips at the <strong>response level</strong> rather than token level, which cleanly drops overly off-policy sequences from contributing to the update, and it uses length-normalized sequence ratios so responses of different lengths live in a comparable numerical range.</p>
<p>Token-level ratio:
$$
\frac{\pi_\theta(y_{i,t}\mid x,y_{i,&lt;t})}{\pi_{\theta_{\text{old}}}(y_{i,t}\mid x,y_{i,&lt;t})}
$$
can be extremely noisy and unstable when applied <em>per token</em>.</p>
<p>Sequence-level ratio:
$$
\frac{\pi_\theta(y_i\mid x)}{\pi_{\theta_{\text{old}}}(y_i\mid x)}
$$​<br>
directly answers: <strong>“How much more likely is the whole sampled response under the new policy than under the old policy?”</strong> That matches how LLM rewards are usually defined: <strong>reward is assigned to the whole response.</strong></p>
<p>GSPO employs the following sequence-level optimization objective:</p>
<p>$$
\mathcal{J} _ { \text{GSPO} } ( \theta ) = \mathbb{E} _ { x \sim D , { y _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | x ) }
$$</p>
<p>$$
[ \frac{1}{G} \sum _ { i = 1 } ^ G \min ( s _ i ( \theta ) \hat{A} _ i , \text{clip} ( s _ i ( \theta ) , 1 - \epsilon , 1 + \epsilon ) \hat{A} _ i ) ]
$$</p>
<p>where,</p>
<p>$$
\hat{A} _ i = \frac{ r ( x , y _ i ) - \text{mean} ( { r ( x , y _ j ) } _ { j = 1 } ^ G ) }{ \text{std} ( { r ( x , y _ j ) } _ { j = 1 } ^ G ) }
$$</p>
<p>and the sequence-level importance ratio:</p>
<p>$$
s _ i ( \theta ) = \left( \frac{ \pi _ \theta ( y _ i | x ) }{ \pi _ { \theta _ { \text{old} } } ( y _ i | x ) } \right) ^ { \frac{1}{ | y _ i | } } = \exp \left( \frac{1}{ | y _ i | } \sum _ { t = 1 } ^ { | y _ i | } \log \frac{ \pi _ \theta ( y _ { i,t } | x , y _ { i, &lt;t } ) }{ \pi _ { \theta _ { \text{old} } } ( y _ { i,t } | x , y _ { i, &lt;t } ) } \right)
$$</p>
<ul>
<li>$\pi_\theta(y_i\mid x)=\prod_t \pi_\theta(y_{i,t}\mid x,y_{i,&lt;t})$ is the likelihood of the full response.</li>
<li>The raw ratio $\pi_\theta(y_i\mid x)/\pi_{\text{old}}(y_i\mid x)$ can explode/vanish for long sequences (product of many factors).</li>
<li>So they take the <strong>geometric mean per token</strong> ($1/|y_i|$ exponent), keeping $s_i(\theta)$ in a stable numeric range and making clipping comparable across different lengths.</li>
<li>Also: <strong>GSPO clips at the response level</strong>, i.e., it drops overly off-policy <em>responses</em> rather than clipping token-by-token.</li>
</ul>
<p>Gradient of GSPO:</p>
<p>$$
\nabla _ \theta \mathcal{J} _ { \text{GSPO} } ( \theta ) = \nabla _ \theta \mathbb{E} _ { x \sim D , { y _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | x ) } \left[ \frac{1}{G} \sum _ { i = 1 } ^ G s _ i ( \theta ) \hat{A} _ i \right]
$$</p>
<p>$$
= \mathbb{E} _ { x \sim D , { y _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | x ) } \left[ \frac{1}{G} \sum _ { i = 1 } ^ G s _ i ( \theta ) \hat{A} _ i \cdot \nabla _ \theta \log s _ i ( \theta ) \right]
$$</p>
<p>$$
= \mathbb{E} _ { x \sim D , { y _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | x ) } \left[ \frac{1}{G} \sum _ { i = 1 } ^ G \left( \frac{ \pi _ \theta ( y _ i | x ) }{ \pi _ { \theta _ { \text{old} } } ( y _ i | x ) } \right) ^ { \frac{1}{ | y _ i | } } \hat{A} _ i \cdot \frac{1}{ | y _ i | } \sum _ { t = 1 } ^ { | y _ i | } \nabla _ \theta \log \pi _ \theta ( y _ { i,t } | x , y _ { i, &lt;t } ) \right]
$$</p>
<p>Gradient of GRPO:</p>
<p>$$
\nabla _ \theta \mathcal{J} _ { \text{GRPO} } ( \theta ) = \nabla _ \theta \mathbb{E} _ { x \sim D , { y _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | x ) } [ \frac{1}{G} \sum _ { i = 1 } ^ G \frac{1}{ | y _ i | } \sum _ { t = 1 } ^ { | y _ i | } w _ { i,t } ( \theta ) \hat{A} _ { i,t } ]
$$</p>
<p>$$
= \mathbb{E} _ { x \sim D , { y _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | x ) } [ \frac{1}{G} \sum _ { i = 1 } ^ G \hat{A} _ i \cdot \frac{1}{ | y _ i | } \sum _ { t = 1 } ^ { | y _ i | } \frac{ \pi _ \theta ( y _ { i,t } | x , y _ { i, &lt;t } ) }{ \pi _ { \theta _ { \text{old} } } ( y _ { i,t } | x , y _ { i, &lt;t } ) } \nabla _ \theta \log \pi _ \theta ( y _ { i,t } | x , y _ { i, &lt;t } ) ]
$$</p>
<p><strong>GSPO-token: token-wise advantages without token-wise IS instability</strong></p>
<p>GSPO-token is introduced for scenarios where the sequence-level advantage $\hat A_i$​ is too coarse, multi-turn RL is the canonical example, so you want the flexibility to assign <strong>token-specific advantages</strong> $\hat A_{i,t}$​. The danger is that if you naïvely go token-level again, you risk reintroducing GRPO’s token-level importance weight problems. GSPO-token avoids that by using a clever <strong>stop-gradient (detach)</strong> construction for $s_{i,t}(\theta)$: numerically, $s_{i,t}$​ equals the same sequence-level ratio $s_i$​, but the gradient is arranged so you still get GSPO-like stable behavior (sequence-level weighting) while allowing per-token advantage shaping. The paper notes an important sanity check: if you set $\hat A_{i,t}=\hat A_i$ for all tokens, then GSPO-token and GSPO become essentially identical (same objective value, same clipping behavior, and the same theoretical gradient). The only difference is that GSPO-token gives you an extra degree of freedom when you <em>do</em> want $\hat A_{i,t}$ to vary across tokens.</p>
<p>$$
\mathcal{J} _ { \text{GSPO-token} } ( \theta ) = \mathbb{E} _ { x \sim D , { y _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | x ) }
$$</p>
<p>$$
\left[ \frac{1}{G} \sum _ { i = 1 } ^ G \frac{1}{ | y _ i | } \sum _ { t = 1 } ^ { | y _ i | } \min ( s _ { i,t } ( \theta ) \hat{A} _ { i,t } , \text{clip} ( s _ { i,t } ( \theta ) , 1 - \epsilon , 1 + \epsilon ) \hat{A} _ { i,t } ) \right]
$$</p>
<p>$$
s _ { i,t } ( \theta ) = \text{sg} [ s _ i ( \theta ) ] \cdot \frac{ s _ i ( \theta ) }{ \text{sg} [ s _ i ( \theta ) ] }
$$</p>
<p>Here $\operatorname{sg}[\cdot]$ means <strong>stop gradient</strong> (PyTorch <code>detach()</code>): it keeps the <strong>numerical value</strong> but blocks backprop through that term.</p>
<h3 id="5-decoupled-clip-and-dynamic-sampling-policy-optimization-dapo">5) Decoupled Clip and Dynamic Sampling Policy Optimization (DAPO)<a hidden class="anchor" aria-hidden="true" href="#5-decoupled-clip-and-dynamic-sampling-policy-optimization-dapo">#</a></h3>
<p>GRPO is a great baseline for “critic-free RL,” but once you push it into <strong>long-CoT, high-variance, large-scale post-training</strong>, it starts to show very practical cracks: batches with almost no learning signal (everyone in the group is either correct or wrong), clipping that quietly strangles exploration, loss reductions that underweight long trajectories (letting repetition/length pathologies slip through) and reward noise introduced by truncation at max length.</p>
<p><a href="https://arxiv.org/abs/2503.14476">DAPO</a> samples a group of outputs ${o_i}_{i=1}^{G}$ for each question $q$ paired with the answer $a$, and optimizes the policy via the following objective:</p>
<p>$$
\mathcal{J} _ { \text{DAPO} } ( \theta ) = \mathbb{E} _ { ( q , a ) \sim \mathcal{D} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) } \left[ \frac{1}{ \sum _ { i = 1 } ^ G | o _ i | } \sum _ { i = 1 } ^ G \sum _ { t = 1 } ^ { | o _ i | } \min ( r _ { i,t } ( \theta ) \hat{A} _ { i,t } , \text{clip} ( r _ { i,t } ( \theta ) , 1 - \epsilon _ { \text{low} } , 1 + \epsilon _ { \text{high} } ) \hat{A} _ { i,t } ) \right]
$$</p>
<p>$ s.t  0 &lt; |({o_i | \ is \ equivalent \ (a, o_i )})| &lt; G $</p>
<p>$$
\text{where} \quad r _ { i,t } ( \theta ) = \frac{ \pi _ \theta ( o _ { i,t } | q , o _ { i, &lt;t } ) }{ \pi _ { \theta _ { \text{old} } } ( o _ { i,t } | q , o _ { i, &lt;t } ) } , \qquad \hat{A} _ { i,t } = \frac{ R _ i - \text{mean} ( { R _ i } _ { i = 1 } ^ G ) }{ \text{std} ( { R _ i } _ { i = 1 } ^ G ) }
$$</p>
<p>DAPO introduces four primary techniques to stabilize and enhance large-scale RL training:</p>
<p><strong>1) Clip-Higher / decoupled clipping:</strong></p>
<p>One of the easiest ways GRPO-style training goes wrong is <strong>entropy collapse</strong>: the policy becomes confident too quickly, generations across a group start looking nearly identical, and learning slows down because there’s no diversity left to compare. Standard PPO/GRPO clipping is a trust-region guardrail, but it’s also a blunt instrument: the usual symmetric bound $1-\epsilon, 1+\epsilon$ caps how much the policy can increase probabilities in a single update. That cap matters most for the tokens you actually <em>need</em> to amplify, rare “exploration” moves in long reasoning traces, because they start at tiny probability and require meaningful uplift to show up in sampling.</p>
<p><strong>Clip-Higher</strong> fixes this by <strong>decoupling</strong> the clip bounds: keep the lower bound conservative (so you don’t aggressively squash probabilities to zero), but raise the upper bound to give the optimizer more room to increase low-probability tokens. In practice, that simple asymmetry increases entropy and keeps the sampling space open longer, making group-based learning more effective on long-horizon reasoning.</p>
<p>$$
\mathcal{J} _ { \text{DAPO} } ( \theta ) = \mathbb{E} _ { ( q , a ) \sim \mathcal{D} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) }
$$</p>
<p>$$
[ \frac{1}{ \sum _ { i = 1 } ^ G | o _ i | } \sum _ { i = 1 } ^ G \sum _ { t = 1 } ^ { | o _ i | } \min ( r _ { i,t } ( \theta ) \hat{A} _ { i,t } , \text{clip} ( r _ { i,t } ( \theta ) , 1 - {\color{red}{ \epsilon _ { \text{low} } }} , 1 + {\color{red}{ \epsilon _ { \text{high} } }} ) \hat{A} _ { i,t } ) ]
$$</p>
<p>$ s.t \  0 &lt; |({o_i | \ is \ equivalent \ (a, o_i )})| &lt; G $</p>
<ul>
<li>$r_{i,t}(\theta)=\dfrac{\pi_\theta(o_{i,t}\mid q,o_{i,&lt;t})}{\pi_{\theta_{\text{old}}}(o_{i,t}\mid q,o_{i,&lt;t})}$ : token-level importance ratio.</li>
<li>$\hat A_{i,t}$​: (group-based) advantage signal copied across tokens of $o_i$​.</li>
<li>$\color{red}ε_{high}$​: the raised ceiling for probability increases (helps exploration).</li>
<li>$\color{red}{\varepsilon_{\mathrm{low}}}$: kept small to avoid collapsing probability mass by over-penalizing decreases.</li>
</ul>
<p><strong>2) Dynamic Sampling:</strong></p>
<p>Dynamic sampling is DAPO’s answer to a very specific GRPO failure mode: <strong>some prompts stop producing gradients</strong> (gradient-decreasing problem). In group-based objectives, the advantage for a prompt is computed <em>relative to the other samples in the same group</em>. If <strong>all</strong> $G$ sampled outputs for a prompt are correct (accuracy =1) and receive essentially the same reward, then every sample looks identical relative to the group baseline, so the advantage collapses to ~0. Once $\hat A \approx 0$, the whole prompt contributes almost no policy gradient. As training progresses, more prompts become “too easy” (all correct) or “too hard” (all wrong), so an increasing fraction of your batch becomes ineffective—gradient magnitude shrinks and noise dominates.</p>
<p><strong>Dynamic sampling</strong> fixes this by <strong>over-sampling and filtering</strong>: keep drawing samples until you build groups where the prompt has <em>some</em> correct and <em>some</em> incorrect responses, i.e., the group has contrast. That guarantees non-trivial advantages and keeps a stable number of “effective prompts” per batch.</p>
<p>The objective stays the same; the key addition is the constraint that the number of correct/equivalent samples is neither 0 nor $G$:</p>
<p>$$
\mathcal{J} _ { \text{DAPO} } ( \theta ) = \mathbb{E} _ { ( q , a ) \sim \mathcal{D} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) }
$$</p>
<p>$$
\left[ \frac{1}{ \sum _ { i = 1 } ^ G | o _ i | } \sum _ { i = 1 } ^ G \sum _ { t = 1 } ^ { | o _ i | } \min ( r _ { i,t } ( \theta ) \hat{A} _ { i,t } , \text{clip} ( r _ { i,t } ( \theta ) , 1 - \epsilon _ { \text{low} } , 1 + \epsilon _ { \text{high} } ) \hat{A} _ { i,t } ) \right]
$$</p>
<p>$ s.t \ \color{red} 0 &lt; |({o_i | \ is \ equivalent \ (a, o_i )})| &lt; G $</p>
<p><strong>3) Token-level Policy Gradient Loss</strong></p>
<p>GRPO’s default reduction is <em>sample-level</em>: you average the token losses inside each sampled completion, then average across completions. That sounds innocuous, but in long-CoT RL it quietly changes what the optimizer “cares about.” If every sample gets equal weight, then <strong>tokens inside long responses get less weight per token</strong> (because you divide by $|o_i|$ first). That has two nasty consequences:</p>
<ol>
<li>
<p><strong>You learn less from high-quality long reasoning.</strong><br>
Even if a long completion contains the exact reasoning patterns you want to reinforce, the per-token contribution is diluted by the within-sample averaging, so the update under-emphasizes those reasoning tokens.</p>
</li>
<li>
<p><strong>You fail to punish long low-quality behavior strongly enough.</strong><br>
A lot of pathological behavior in RL post-training is length-amplified: repetition loops, filler text, “gibberish drift,” etc. With sample-level averaging, that garbage can hide inside long sequences because its per-token penalty is also diluted. The result is a training dynamic where entropy and response length can creep upward in an unhealthy way: the model can “get away” with producing longer, noisier outputs without being penalized proportionally.</p>
</li>
</ol>
<p>DAPO’s fix is to switch to a <strong>token-level policy gradient loss</strong>: instead of giving each completion equal weight, give <strong>tokens</strong> a more uniform vote in the gradient by normalizing by the <strong>total number of tokens across the group</strong> $\sum_{i=1}^G |o_i|$. That way, long sequences (which contain more tokens) naturally contribute more to the update, both in positive signal (good long reasoning) and negative signal (repetition/gibberish).</p>
<p><strong>4) Overlong Reward Shaping:</strong></p>
<p>Long-CoT RL almost always runs with a <strong>max generation length</strong>. Anything that goes past that cap gets truncated. The subtle problem is what you do <em>next</em>: a common default is to slap a big negative reward on truncated samples. But that mixes up two different failure modes, “the reasoning is wrong” vs “the reasoning didn’t finish in time.” A perfectly valid chain-of-thought can get punished just because it was verbose, and that injects <strong>reward noise</strong>: the model can’t tell whether it’s being penalized for incorrect reasoning or for hitting the length limit. Over time, this kind of noisy signal can destabilize training and distort behavior (e.g., forcing premature endings or weird compression tricks).</p>
<p>To isolate this effect, the paper first introduces <strong>Overlong Filtering</strong>: if a sample is truncated, they <strong>mask its loss</strong> (i.e., don’t backprop that trajectory). This simple move already stabilizes training, which is a strong sign that “punitive truncation reward” is indeed contaminating the learning signal.</p>
<p>Then they go one step further with <strong>Soft Overlong Punishment</strong>: instead of a cliff-like penalty that only triggers after truncation (or a constant punishment for all truncated outputs), they add a <strong>length-aware penalty ramp</strong> near the maximum length. The idea is: keep the original correctness/verifier reward as the main driver, but add a smooth “wrap it up” signal in the last stretch of the <a href="https://www.ibm.com/think/topics/context-window">context window</a>. That encourages concision without corrupting the reward for reasoning quality too early.</p>
<p><strong>Soft Overlong Punishment</strong>:</p>
<p>$$
R _ { \text{length} } ( y ) =
$$</p>
<p>$$
| y | \le L _ { \text{max} } - L _ { \text{cache} } \quad \rightarrow \quad 0
$$</p>
<p>$$
L _ { \text{max} } - L _ { \text{cache} } &lt; | y | \le L _ { \text{max} } \quad \rightarrow \quad \frac{ ( L _ { \text{max} } - L _ { \text{cache} } ) - | y | }{ L _ { \text{cache} } }
$$</p>
<p>$$
L _ { \text{max} } &lt; | y | \quad \rightarrow \quad -1
$$</p>
<ul>
<li><strong>$y$</strong>: the generated response (sequence).</li>
<li><strong>$|y|$</strong>: response length (tokens).</li>
<li><strong>$⁡L_{\max}$</strong>: maximum allowed length before truncation.</li>
<li><strong>$L_{\text{cache}}$​</strong>: a “buffer zone” length near the end where the penalty ramps up.</li>
</ul>
<p>How to read the piecewise reward</p>
<ul>
<li>
<p><strong>Safe zone</strong> $|y|\le L_{\max}-L_{\text{cache}}$: no length penalty.</p>
</li>
<li>
<p><strong>Ramp zone</strong> $L_{\max}-L_{\text{cache}}&lt;|y|\le L_{\max}$​: penalty becomes more negative as you approach the cap.</p>
</li>
<li>
<p><strong>Over cap</strong> $L_{\max}&lt;|y|$: hard penalty −1.</p>
</li>
</ul>
<p>And then the <strong>total reward</strong> is (conceptually) the original correctness reward plus this shaping term:</p>
<p>$$
R(y)=R_{\text{task}}(y)+R_{\text{length}}(y).
$$</p>
<h3 id="6-cispo-clipped-is-weight-policy-optimization">6) CISPO (Clipped IS-weight Policy Optimization)<a hidden class="anchor" aria-hidden="true" href="#6-cispo-clipped-is-weight-policy-optimization">#</a></h3>
<p><a href="https://arxiv.org/pdf/2506.13585">CISPO</a> starts from a very specific observation about <strong>PPO/GRPO-style clipping</strong> in LLM post-training. In long reasoning traces, the tokens that matter most (those “fork” tokens that trigger reflection or a correction (“Wait”, “However”, “Recheck”, “Aha”, etc.)), tend to be <strong>rare</strong> under the base policy. Rare tokens means <strong>low probability</strong>, and low probability tokens are exactly the ones that can end up with <strong>large importance ratios</strong> $r_{i,t}(\theta)​$ when the new policy begins to increase them.</p>
<p>Now here’s the nasty part: under PPO/GRPO, once a token’s ratio falls outside the clip window, it can get effectively <strong>clipped out</strong> (i.e., its gradient contribution becomes zero under the trust-region-style min/clip behavior). In multi-step minibatch training (many off-policy update rounds per batch), that means these “rare-but-important” tokens contribute a bit early, then get <strong>dropped after the first on-policy update</strong>, and stop contributing to subsequent updates. DAPO’s “clip-higher” tries to loosen the upper bound to keep exploration alive but the CISPO paper argues this is still less effective in their setup, especially with many update rounds.</p>
<p><strong>The CISPO Solution:</strong> Unlike GRPO, which drops tokens entirely when they exceed a threshold, <strong>CISPO clips the importance sampling weights themselves</strong> rather than the token updates. This ensures that the model <strong>always leverages all tokens for gradient computations</strong>, preserving the contributions of rare, high-importance tokens.</p>
<p>CISPO is built upon the vanilla REINFORCE objective but incorporates a corrected distribution for offline updates. The key is the <strong>stop-gradient</strong> operator $\mathrm{sg}(\cdot)$: the importance ratio is used as a <em>weight</em> but you don’t backprop through it:</p>
<p>$$
\mathcal{J} _ { \text{REINFORCE} } ( \theta ) = \mathbb{E} _ { ( q , a ) \sim \mathcal{D} , o _ i \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) }
$$</p>
<p>$$
\left[ \frac{1}{ | o _ i | } \sum _ { t = 1 } ^ { | o _ i | } \text{sg} ( r _ { i,t } ( \theta ) ) \hat{A} _ { i,t } \log \pi _ \theta ( o _ { i,t } | q , o _ { i, &lt;t } ) \right]
$$</p>
<ul>
<li>$r_{i,t}(\theta)=\dfrac{\pi_\theta(o_{i,t}\mid q,o_{i,&lt;t})}{\pi_{\theta_{\mathrm{old}}}(o_{i,t}\mid q,o_{i,&lt;t})}$ :​ is the token-level IS weight.</li>
<li>$\hat A^{i,t}​$ is the advantage (in GRPO-style, usually a group-relative normalized reward).</li>
<li>$\mathrm{sg}$ (“stop grad”) means: treat the ratio as a constant scaler to avoid nasty second-order effects / instability</li>
</ul>
<p><strong>CISPO = clip the IS weight (not the token update):</strong></p>
<p>Instead of PPO/GRPO’s “min with clipped ratio times advantage”, CISPO just uses the policy-gradient form, but replaces $r_{i,t}$​ with a <strong>clipped IS weight</strong> $\hat r_{i,t}$​.</p>
<p>$$
\mathcal{J} _ { \text{CISPO} } ( \theta ) = \mathbb{E} _ { ( q , a ) \sim \mathcal{D} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) }
$$</p>
<p>$$
\left[ \frac{1}{ \sum _ { i = 1 } ^ G | o _ i | } \sum _ { i = 1 } ^ G \sum _ { t = 1 } ^ { | o _ i | } \text{sg} ( \hat{r} _ { i,t } ( \theta ) ) \hat{A} _ { i,t } \log \pi _ \theta ( o _ { i,t } | q , o _ { i, &lt;t } ) \right]
$$</p>
<p>$$
\hat{r} _ { i,t } ( \theta ) = \text{clip} ( r _ { i,t } ( \theta ) , 1 - \epsilon _ { \text{low} } ^ { \text{IS} } , 1 + \epsilon _ { \text{high} } ^ { \text{IS} } )
$$</p>
<ul>
<li>PPO/GRPO clipping is effectively a <strong>gate</strong>: if a token’s ratio is too large/small (depending on advantage sign), the gradient can become <strong>0</strong> → token is “dropped” from learning.</li>
<li>CISPO clipping is a <strong>cap</strong>: the token still contributes, it just can’t contribute an arbitrarily huge weight.</li>
</ul>
<p>So CISPO trades “hard token dropping” for “soft weight saturation.” That keeps the learning signal alive for rare-but-important tokens, especially across repeated off-policy updates.</p>
<p><strong>Token-wise mask $M_{i,t}$​</strong>:</p>
<p>The MiniMax-M1 paper then shows a clean way to see PPO-style clipping as an implicit mask. They define a unified objective with a token-wise multiplier $M_{i,t}$​:</p>
<p>$$
\mathcal{J} _ { \text{unify} } ( \theta ) = \mathbb{E} _ { ( q , a ) \sim \mathcal{D} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) }
$$</p>
<p>$$
\left[ \frac{1}{ \sum _ { i = 1 } ^ G | o _ i | } \sum _ { i = 1 } ^ G \sum _ { t = 1 } ^ { | o _ i | } \text{sg} ( \hat{r} _ { i,t } ( \theta ) ) \hat{A} _ { i,t } \log \pi _ \theta ( o _ { i,t } | q , o _ { i, &lt;t } ) M _ { i,t } \right]
$$</p>
<p>Then explicitly write the mask corresponding to the PPO trust region:</p>
<p>$$
M _ { i,t } =
$$</p>
<p>$$
\hat{A} _ { i,t } &gt; 0 \quad \text{and} \quad r _ { i,t } ( \theta ) &gt; 1 + \epsilon _ { \text{high} } \quad \rightarrow \quad 0
$$</p>
<p>$$
\hat{A} _ { i,t } &lt; 0 \quad \text{and} \quad r _ { i,t } ( \theta ) &lt; 1 - \epsilon _ { \text{low} } \quad \rightarrow \quad 0
$$</p>
<p>$$
\text{otherwise} \quad \rightarrow \quad 1
$$</p>
<p>While the unified formulation includes $M_{i,t}$ for flexibility, CISPO effectively moves away from the binary masking of PPO/GRPO. Instead of setting $M_{i,t}$​ to zero for large updates, CISPO <strong>clips the importance sampling weight itself</strong> ($r^{i,t}$​). By doing this, CISPO ensures that the model <strong>always leverages all tokens for gradient computations</strong>, preserving the contributions of rare but high-importance reasoning tokens while still maintaining training stability through weight clipping.</p>
<h3 id="7-geometric-mean-policy-optimization-gmpo">7) Geometric Mean Policy Optimization (GMPO)<a hidden class="anchor" aria-hidden="true" href="#7-geometric-mean-policy-optimization-gmpo">#</a></h3>
<p><a href="https://arxiv.org/abs/2507.20673">GMPO (Geometric-Mean Policy Optimization)</a> is a very “surgical” fix to a very specific GRPO failure mode: <strong>token-level importance ratios $\rho_{i,t}$​ can develop nasty outliers</strong>, and GRPO’s arithmetic-mean objective is <em>too sensitive</em> to those outliers, so one or two extreme tokens can dominate the update and push the policy into unstable territory. The GMPO paper visualizes this directly: during GRPO training the range of $\log \rho_t(\theta)$ keeps expanding with lots of extreme spikes (“unstable policy updates”), while GMPO keeps the ratio range tighter with fewer outliers.</p>
<p><img alt="GMPO" loading="lazy" src="/images/GMPO.png"></p>
<p>In GRPO, each generated token contributes an importance-weighted term using:</p>
<p>$$\rho_{i,t}(\theta)=\frac{\pi_\theta(o_{i,t}\mid q,o_{i,&lt;t})}{\pi_{\theta_{\text{old}}}(o_{i,t}\mid q,o_{i,&lt;t})}$$</p>
<p>If $\rho_{i,t}$​ gets extreme (very large or very small), the corresponding token’s contribution to the update can become extreme too. The GMPO paper’s diagnosis is: <strong>GRPO optimizes an arithmetic mean over token-level “rewards” (importance-weighted advantages)</strong>, and the arithmetic mean is notoriously sensitive to outliers, so a few pathological tokens can drive aggressive updates, which then create even more extreme $\rho$’s, and the loop feeds itself.</p>
<p>Conceptually:</p>
<ul>
<li><strong>GRPO:</strong> average token contributions with an <strong>arithmetic mean</strong>: $\frac{1}{|o_i|}\sum_t (\cdot)$</li>
<li><strong>GMPO:</strong> aggregate token contributions with a <strong>geometric mean</strong>: $\left(\prod_t (\cdot)\right)^{1/|o_i|}$</li>
</ul>
<p>Geometric mean is much more robust: one extreme token can’t blow up the whole objective as easily because products + root behave like <strong>averaging in log-space</strong>.</p>
<p>The paper first introduces GMPO (ignoring clipping for the moment) as maximizing the geometric mean of token-level terms; they also include a $\mathrm{sgn}(\hat A_i)$ so the optimization direction stays correct when the group advantage is negative:</p>
<p>$$
\mathcal{J} ^ { * } _ { \text{GMPO} } ( \pi _ \theta ) = \mathbb{E} _ { q \sim \mathcal{Q} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) }
$$</p>
<p>$$
\left[ \frac{1}{G} \sum _ { i = 1 } ^ G \left( \prod _ { t = 1 } ^ { | o _ i | } | \rho _ { i,t } ( \theta ) \hat{A} _ i | \right) ^ { \frac{1}{ | o _ i | } } \cdot \text{sgn} ( \hat{A} _ i ) \right]
$$</p>
<p>Then they “expand” it to include PPO-style clipping <strong>at the token level</strong>:</p>
<p>$$\mathcal{J} _ { \text{GMPO} } ( \pi _ \theta ) = \mathbb{E} _ { q , { o _ i } } [ \text{Group Average of Response Scores} ]$$</p>
<p><strong>Step 1: Per-Token Clipped Signal</strong>
$$\mathcal{C} _ { i,t } = \min [ \rho _ { i,t } ( \theta ) \hat{A} _ i , \text{clip} ( \rho _ { i,t } ( \theta ) , \epsilon _ { \text{low} } , \epsilon _ { \text{high} } ) \hat{A} _ i ]$$</p>
<p><strong>Step 2: Sequence Geometric Mean</strong>
$$\text{Score} _ i = ( \prod _ { t = 1 } ^ { | o _ i | } | \mathcal{C} _ { i,t } | ) ^ { 1 / | o _ i | } \cdot \text{sgn} ( \hat{A} _ i )$$</p>
<p><strong>Step 3: Final Objective</strong>
$$\mathcal{J} = \frac{1}{G} \sum _ { i = 1 } ^ G \text{Score} _ i$$</p>
<p>The paper shows:
$$| \mathcal{J} ^ { * } _ { \text{GMPO} } | \le | \mathcal{J} ^ { * } _ { \text{GRPO} } |$$
using the classic <a href="https://en.wikipedia.org/wiki/AM%E2%80%93GM_inequality"><strong>AM–GM inequality</strong></a> intuition: geometric mean is always $\le$ arithmetic mean for non-negative numbers. That “narrower range” is their theoretical proxy for lower variance / less sensitivity to outliers → more stable updates.</p>
<p>$$
\left| \mathcal{J} ^ { * } _ { \text{GMPO} } ( \pi _ \theta ) \right| = \mathbb{E} _ { q \sim \mathcal{Q} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) } \left[ \frac{1}{G} \sum _ { i = 1 } ^ G \left( \prod _ { t = 1 } ^ { | o _ i | } | \rho _ { i,t } ( \theta ) \hat{A} _ i | \right) ^ { \frac{1}{ | o _ i | } } \right]
$$</p>
<p>$$
\le \mathbb{E} _ { q \sim \mathcal{Q} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) } \left[ \frac{1}{G} \sum _ { i = 1 } ^ G \frac{1}{ | o _ i | } \sum _ { t = 1 } ^ { | o _ i | } | \rho _ { i,t } ( \theta ) \hat{A} _ i | \right] = \left| \mathcal{J} ^ { * } _ { \text{GRPO} } ( \pi _ \theta ) \right|
$$</p>
<p><strong>Gradient intuition</strong>:</p>
<p>This is the most important “mechanistic” difference.</p>
<ul>
<li>
<p><strong>GRPO gradient:</strong> token $t$ is weighted by its <strong>own</strong> ratio $\rho_{i,t}$​. One extreme token can blow up its gradient weight.</p>
</li>
<li>
<p><strong>GMPO gradient:</strong> token $t$ is weighted by the <strong>geometric mean of ratios across the whole sequence</strong>, roughly $\left(\prod_k \rho_{i,k}\right)^{1/|o_i|}$. So even if one $\rho_{i,t}$​ is extreme, the sequence-level geometric mean damps it.</p>
</li>
</ul>
<p>$$
\nabla _ { \theta } \mathcal{J} ^ { * } _ { \text{GRPO} } ( \pi _ \theta ) | _ { q , o _ i } = \frac{1}{ G \cdot | o _ i | } \sum _ { t = 1 } ^ { | o _ i | } {\color{red}\rho _ { i,t } ( \theta )} \cdot \hat{A} _ i \cdot \nabla _ { \theta } \log \pi _ \theta ( o _ { i,t } | q , o _ { i, &lt;t } )
$$</p>
<p>$$
\nabla _ { \theta } \mathcal{J} ^ { * } _ { \text{GMPO} } ( \pi _ \theta ) | _ { q , o _ i } = \frac{1}{ G \cdot | o _ i | } \sum _ { t = 1 } ^ { | o _ i | } \left ( \prod _ { k = 1 } ^ { | o _ i | } {\color{blue}\rho _ { i,k } ( \theta )} \right) ^ { \frac{1}{ | o _ i | } } \cdot \hat{A} _ i \cdot \nabla _ { \theta } \log \pi _ \theta ( o _ { i,t } | q , o _ { i, &lt;t } )
$$</p>
<p><strong>(i) Token-level clipping (vs sequence-level clipping)</strong></p>
<p>The paper argues <strong>sequence-level clipping is too aggressive</strong>: if you clip the whole product term at once, once the clip triggers you can zero out gradients for <em>all tokens</em> in the sequence, throwing away useful learning signal. Token-level clipping is more “local” and tends to be more stable.</p>
<p><strong>(ii) Clip wider (in the DAPO spirit, but safer)</strong></p>
<p>Like DAPO, they want more exploration by widening the clip range (because tight clipping can make policies go deterministic early). But they claim GMPO can afford wider clipping <em>without</em> exploding, because the geometric mean suppresses outliers in $\rho$ more naturally.</p>
<h3 id="8-router-shift-policy-optimization-rspo">8) Router-Shift Policy Optimization (RSPO)<a hidden class="anchor" aria-hidden="true" href="#8-router-shift-policy-optimization-rspo">#</a></h3>
<p><a href="https://www.alphaxiv.org/abs/2510.23027">RSPO</a> sits in a very specific corner of post-training: <strong>off-policy RL (multiple update rounds per batch) for MoEs</strong>. In dense LMs, “off-policy drift” is mostly about the token distribution $\pi_\theta(\cdot)$ moving away from the behavior policy $\pi_{\theta_{\text{old}}}$. In MoE, you implicitly introduce a second stochastic system: the <strong>router distribution</strong> over experts. After an update, the router can (a) change the top-K experts selected for the same token, and/or (b) keep the same top-K but reweight them. The paper emphasizes both effects, and notes that even modest changes in routing can cause <em>large</em> fluctuations in token-level importance ratios, frequently triggering clipping and injecting extra variance.</p>
<p>GRPO’s token-level IS ratios and clipping were designed for settings where the policy is a single distribution over actions. In MoE, the induced distribution over tokens is a mixture whose components and mixing weights can change abruptly between updates.</p>
<p><strong>GRPO in MoE exhibits two coupled sources of instability:</strong></p>
<p><strong>(1) Router-induced IS volatility (routing fluctuations)</strong></p>
<p>Let the token probability decompose as a mixture:</p>
<p>$\pi_\theta(o_{t}\mid h_t)=\sum_{e\in\mathcal{E}} r_\phi(e\mid h_t),\pi_{\theta,e}(o_t\mid h_t)$</p>
<p>where $r_\phi$ is the router distribution (parameters $\phi$), and $\pi_{\theta,e}$,is the expert-conditional distribution.</p>
<p>The token-level importance ratio used by GRPO is:
$$
w_t(\theta)=\frac{\pi_\theta(o_t\mid h_t)}{\pi_{\theta_{\text{old}}}(o_t\mid h_t)}
$$</p>
<p>Even if the expert networks $\pi_{\theta,e}$ barely changed, a change in $r_\phi(e\mid h_t)$ can shift $\pi_\theta(o_t\mid h_t)$ sharply, especially when mass moves between a few high-weight experts. This pushes $w_t$​ into the clip region more often (or creates outliers that dominate gradients before clipping), which is exactly the failure mode they illustrate and connect to prior MoE observations (e.g., StableMoE).</p>
<p><strong>(2) Variance mismatch (sequence reward vs token IS)</strong></p>
<p>Most RLVR setups attach reward at the <strong>sequence level</strong> (rule-based verifier / outcome reward), then propagate learning through token-level policy gradients. GRPO often combines <strong>sequence-level advantage</strong> with <strong>token-level IS weights</strong>, which is already a mismatch in dense LMs; in MoE it’s amplified because variance at the token level now includes router variance. The RSPO paper flags this explicitly as “variance mismatch” that, together with routing fluctuations, hinders stable learning.</p>
<p><strong>RSPO objective: geometric-mean aggregation + token-level clipping + router-shift reweighting</strong></p>
<p>RSPO keeps a <strong>sequence-level aggregation</strong> (geometric mean over tokens), but uses <strong>token-level clipping</strong> (to avoid “all-or-nothing” pruning), and multiplies each token’s contribution by a <strong>router-shift ratio</strong> $\gamma_{i,t}$​ that down-weights tokens whose routing changed too much.</p>
<p>$$
\text{Sequence Score} _ i = [ \prod _ { t = 1 } ^ { | o _ i | } ( \mathcal{W} _ { i,t } \cdot \gamma _ { i,t } ) ] ^ { \frac{ \text{sgn} ( \hat{A} _ i ) }{ | o _ i | } }
$$</p>
<p>$$
\mathcal{W} _ { i,t } = \min [ ( w _ { i,t } ( \theta ) ) ^ { \text{sgn} ( \hat{A} _ i ) } , \text{clip} ( ( w _ { i,t } ( \theta ) ) ^ { \text{sgn} ( \hat{A} _ i ) } , \varepsilon _ 1 , \varepsilon _ 2 ) ]
$$</p>
<p>$$
\mathcal{J} _ { \text{RSPO} } ( \pi _ \theta ) = \mathbb{E} _ { x \sim \mathcal{Q} , { o _ i } _ { i = 1 } ^ G \sim \pi _ { \text{old} } } \left[ \frac{1}{G} \sum _ { i = 1 } ^ G \mathcal{S} _ i \cdot \hat{A} _ i \right]
$$</p>
<ul>
<li>
<p><strong>$w_{i,t}(\theta)$</strong>: token-level importance sampling ratio (same as GRPO), comparing current vs old policy for token $o_{i,t}$​:</p>
</li>
<li>
<p><strong>$\hat A_i$</strong>: (group) advantage for the $i$-th response $o_i$​, defined as in GRPO (sequence-level signal used to scale updates).</p>
</li>
<li>
<p><strong>$\mathrm{sgn}(\hat A_i)$</strong>: sign of the advantage (+1 if $\hat A_i&gt;0$, −1 if $\hat A_i&lt;0$); used so clipping behaves correctly for positive vs negative updates:</p>
</li>
<li>
<p><strong>$γ_{i,t}$​</strong>: <strong>router shift ratio</strong> for token $t$ in response $o_i$; measures routing drift between old and current routers and scales (down-weights) the token’s contribution after clipping.</p>
</li>
<li>
<p><strong>$r^{(\ell)}_{\phi}(\cdot)$</strong>: routing score / routing probability under router parameters $\phi$ at MoE layer $\ell$.</p>
</li>
<li>
<p><strong>$r^{(\ell)}_{\phi _ {\text{old}}}(\cdot)$</strong>: the same, but for the old router $\phi_{\text{old}}$​.</p>
</li>
<li>
<p><strong>$e^{(\ell)}_{i,t}$​</strong>: the expert associated with token position $(i,t)$ at layer $\ell$ (often top-K experts are considered).</p>
</li>
<li>
<p><strong>Top-K experts</strong>: RSPO estimates routing drift by averaging routing-score differences over the <strong>top-K</strong> experts that were activated under the old policy during log-prob computation.</p>
</li>
<li>
<p><strong>Multiplicative aggregation across layers</strong>: since routing deviations can accumulate with depth, per-layer router shifts are combined multiplicatively to form the final $\gamma_{i,t}$​ (implemented via sums of log differences inside an $\exp(\cdot)$.</p>
</li>
<li>
<p><strong>Where $\gamma_{i,t}$​ is applied</strong>: $\gamma_{i,t}$ is used as a <strong>reweighting factor after token-level clipping</strong>, preserving the original trust-region behavior while further damping tokens with excessive routing drift.</p>
</li>
<li>
<p><strong>the router-shift weight</strong> $\gamma_{i,t}$​:</p>
</li>
</ul>
<p>$$
\gamma _ { i,t } = \exp \left( - \frac{1}{ L } \sum _ { \ell = 1 } ^ { L } \frac{1}{ K } \sum _ { k = 1 } ^ { K } | \log r _ \phi ^ { ( \ell ) } ( e _ { i,t } ^ { ( \ell,k ) } | x, y _ { i,&lt;t } ) - \log r _ { \phi _ { \text{old} } } ^ { ( \ell ) } ( e _ { i,t } ^ { ( \ell,k ) } | x, y _ { i,&lt;t } ) | \right)
$$</p>
<p>$\gamma_{i,t}=\max(\gamma_{i,t},\gamma_{\min})$
$\text{Use } \mathrm{sg}[\gamma_{i,t}] \text{ (stop-gradient) so } \gamma_{i,t} \text{ acts only as a sample weight.}$</p>
<p><strong>What $\gamma_{i,t}$​ is measuring?</strong></p>
<p>For each generated token position $t$ in response $i$, RSPO looks across:</p>
<ul>
<li><strong>all MoE layers</strong> $\ell = 1,\dots,L$</li>
<li>the <strong>top-K</strong> experts considered/activated at that layer, indexed by $k=1,\dots,K$</li>
</ul>
<p>and compares the router’s <strong>log routing scores</strong> under the current router $\phi$ vs the old router $\phi_{\text{old}}$​:
$$
\log r _ \phi ^ { ( \ell ) } ( e _ { i,t } ^ { ( \ell,k ) } | x, y _ { i,&lt;t } ) \quad \text{vs} \quad \log r _ { \phi _ { \text{old} } } ^ { ( \ell ) } ( e _ { i,t } ^ { ( \ell,k ) } | x, y _ { i,&lt;t } )
$$
It takes an absolute difference $|\cdot|$ (so “changed up or down” both count), averages over experts and layers $\frac{1}{L}\sum_{\ell}\frac{1}{K}\sum_k$​, then exponentiates the negative of that:
$$\gamma_{i,t}=\exp(-\text{avg drift})$$</p>
<p><strong>Why the exponential form?</strong></p>
<ul>
<li>If the router barely changed: average drift $\approx 0$ → $\gamma_{i,t}\approx e^0=1$.</li>
<li>If the router changed a lot: average drift large → $\gamma_{i,t}$​ becomes small (close to 0).</li>
</ul>
<p>So $\gamma_{i,t}\in(0,1]$ acts like a <strong>soft reliability score</strong>:</p>
<ul>
<li><strong>$\gamma_{i,t}\approx 1$</strong>: routing is consistent → token-level IS ratios are more trustworthy.</li>
<li><strong>$\gamma_{i,t}\ll 1$</strong>: routing drift is big → token-level IS ratios are noisy/unreliable → down-weight this token’s contribution.</li>
</ul>
<p>$γ_{i,t}$​ is a <strong>routing-drift penalty</strong>: <em>the more the router changed for token $t$, the less RSPO lets that token push the policy update</em></p>
<p><strong>Why “stop-gradient” through $\gamma_{i,t}$​?</strong></p>
<p>Gradients do <strong>not</strong> flow into the router via $\gamma$. Otherwise, the optimizer could “cheat” by manipulating routing just to inflate $\gamma$, or you’d introduce messy second-order interactions where $\gamma$ itself becomes a learnable pathway. With stop-grad, $\gamma$ is purely a <strong>stability filter</strong>: it modulates how much you trust the token’s update, but doesn’t become a new optimization target.</p>
<h3 id="9-soft-adaptive-policy-optimization-sapo">9) Soft Adaptive Policy Optimization (SAPO)<a hidden class="anchor" aria-hidden="true" href="#9-soft-adaptive-policy-optimization-sapo">#</a></h3>
<p>Group-based RL for LLM post-training typically relies on importance ratios to reuse trajectories across policy updates, but in practice those ratios are <em>noisy at the token level</em>, and the variance is especially acute in Mixture-of-Experts models, where routing heterogeneity and long generations amplify per-token deviations. The standard remedy in <strong>GRPO</strong> is <strong>hard token clipping</strong>: once a token’s ratio exits a fixed band, its contribution is effectively truncated to zero gradient, which stabilizes extreme steps but creates a brittle trade-off, tight clipping wastes samples and kills learning signal, while looser clipping admits off-policy noise and destabilizes optimization. <strong>GSPO</strong> shifts the trust region to the <strong>sequence level</strong> to enforce coherence with sequence rewards, but this introduces a different pathology: a small number of outlier tokens can push the <em>sequence ratio</em> beyond the clip band, causing the entire sequence’s gradients (including many near-on-policy, informative tokens) to be suppressed. <a href="https://arxiv.org/abs/2511.20347?spm=a2ty_o06.30285417.0.0.3107c921VbuzgU&amp;file=2511.20347"><strong>Soft Adaptive Policy Optimization (SAPO)</strong></a> is proposed to resolve this “hard-gate brittleness” by replacing clipping with a <strong>temperature-controlled soft gate</strong> over importance ratios: near the on-policy point ($r\approx 1$), gradients are preserved to encourage learning and exploration; as ratios drift, updates are <strong>attenuated smoothly rather than truncated</strong>, retaining useful signal from moderate deviations while damping high-variance outliers. Crucially, SAPO is designed to be <strong>sequence-coherent yet token-adaptive</strong>: under empirically common conditions (small policy steps and low intra-sequence dispersion of token log-ratios), the <em>average token gate</em> concentrates into a smooth <strong>sequence-level gate</strong> (GSPO-like behavior, but with a continuous trust region), while in the presence of heterogeneous or outlier tokens it selectively down-weights only the offending tokens instead of collapsing the whole sequence.</p>
<p><strong>SAPO objective: “grouped RL” + a gating function over importance ratios:</strong></p>
<p>SAPO optimizes a grouped surrogate:</p>
<p>$$
\mathcal{J} ( \theta ) = \mathbb{E} _ { q \sim \mathcal{D} , { y _ i } _ { i = 1 } ^ G \sim \pi _ { \theta _ { \text{old} } } ( \cdot | q ) }
$$</p>
<p>$$
\left[ \frac{1}{G} \sum _ { i = 1 } ^ G \frac{1}{ | y _ i | } \sum _ { t = 1 } ^ { | y _ i | } f _ { i,t } ( r _ { i,t } ( \theta ) ) \hat{A} _ { i,t } \right]
$$</p>
<ul>
<li>$q\sim \mathcal D$: prompt/query drawn from your prompt distribution.</li>
<li>${y_i}_{i=1}^G \sim \pi _ {\theta _ {\text{old}}}(\cdot|q)$: you sample a <em>group</em> of $G$ responses from the <strong>behavior policy</strong> (the “old” policy). This is the GRPO/GSPO regime: generate many candidates, compare within a group, update current policy.</li>
<li><strong>$\frac{1}{|y_i|}\sum_t$​</strong>: length-normalization so long generations don’t dominate purely by having more tokens.</li>
<li><strong>$\hat A_{i,t}$​</strong>: advantage signal (often group-normalized reward); in many group-RL setups it’s constant across tokens in a response, i.e.$\hat A_{i,t}=\hat A_i$​. It tells you “this whole sampled trajectory was better/worse than its siblings.”</li>
<li><strong>$r_{i,t}(\theta)$</strong>: token-level importance ratio:</li>
</ul>
<p>$$
r_{i,t}(\theta)=\frac{\pi_\theta(y_{i,t}\mid q,y_{i,&lt;t})}{\pi_{\theta_{\text{old}}}(y_{i,t}\mid q,y_{i,&lt;t})}
$$</p>
<p>If $r\approx 1$: current policy is close to behavior policy at that token (near on-policy). If $r$ is far from 1, you’re reusing a token that is effectively off-policy for the current model, high-variance / risky to trust.</p>
<p>The <em>entire novelty</em> is the choice of the <strong>gating function</strong> $f_{i,t}(\cdot)$: instead of GRPO/GSPO’s <strong>hard clipping</strong>, SAPO uses a <strong>smooth, temperature-controlled soft gate</strong> that <em>attenuates</em> off-policy tokens rather than truncating them.</p>
<p><strong>The SAPO gate:</strong></p>
<p>$$
f _ { i,t } ( x ) = \sigma ( \tau _ { i,t } ( x - 1 ) ) \cdot \frac{ 4 }{ \tau _ { i,t } }
$$</p>
<p>Where the temperature parameter $\tau _ { i,t }$ is:</p>
<p>$$
\tau _ { i,t } = \tau _ { \text{pos} } \quad \text{if} \quad \hat{A} _ { i,t } &gt; 0 \quad \text{else} \quad \tau _ { \text{neg} }
$$</p>
<ul>
<li>
<p><strong>Centering at $x−1$</strong>: the “trust region center” is $r=1$ (on-policy). Everything is about how far your current policy deviates from the behavior policy.</p>
</li>
<li>
<p><strong>$\sigma(\tau(x-1))$</strong>: smooth monotone gate. Temperature $\tau$ controls <em>steepness</em>:</p>
<ul>
<li>
<p>small $\tau$ ⇒ gentle decay (more tolerant of deviation),</p>
</li>
<li>
<p>large $\tau$ ⇒ sharp decay (more conservative).</p>
</li>
</ul>
</li>
<li>
<p><strong>Asymmetric temperatures $\tau_{\text{pos}}$, $\tau_{\text{neg}}$​</strong>: SAPO intentionally treats positive-advantage and negative-advantage updates differently.</p>
</li>
<li>
<p><strong>The factor $4/\tau$</strong> looks like a hack, but it’s actually a <em>calibration</em>: it makes the resulting gradient weight nicely normalized so that the effective weight peaks at 1 at the on-policy point. This is why SAPO preserves “unclipped behavior” near $r=1$ regardless of $\tau$.</p>
</li>
</ul>
<p><strong>Differentiating SAPO gives a weighted log-policy gradient</strong>:</p>
<p>if we differentiate the SAPO objective using $\nabla_\theta r = r\nabla_\theta \log \pi_\theta(\cdot)$ we get:</p>
<p>$$
\nabla _ \theta \mathcal{J} ( \theta ) = \mathbb{E} \left[ \frac{1}{ G } \sum _ { i = 1 } ^ G \frac{1}{ | y _ i | } \sum _ { t = 1 } ^ { | y _ i | } w _ { i,t } ( \theta ) \cdot r _ { i,t } ( \theta ) \cdot \nabla _ \theta \log \pi _ \theta ( y _ { i,t } | q , y _ { i, &lt;t } ) \cdot \hat{A} _ { i,t } \right]
$$</p>
<p>where -
$$
w_{i,t}(\theta)=4 \ p_{i,t}(\theta)\big(1-p_{i,t}(\theta)\big),
\qquad
p_{i,t}(\theta)=\sigma\big(\tau_{i,t}(r_{i,t}(\theta)-1)\big).
$$</p>
<p><strong>$w_{i,t}$​ is a smooth trust-region <em>kernel</em></strong></p>
<ul>
<li>$p(1−p)$ is maximized at $p =1/2$.</li>
<li>$p=1/2$ happens exactly when $\tau(r-1)=0$ ⇒ <strong>$r=1$</strong>.</li>
<li>Therefore, <strong>$w_{i,t}$​ peaks at 1 when $r_{i,t}=1$</strong> and decays smoothly as $r$ moves away from 1.</li>
</ul>
<p>Concretely:</p>
<ul>
<li>If $r\approx 1$ : $w\approx 1$, SAPO behaves like the unclipped objective (strong learning signal).</li>
<li>If $r$ is moderately off: $w\in(0,1)$, you still learn but cautiously.</li>
<li>If $r$ is extremely off: $w\to 0$, SAPO essentially ignores those tokens, but <strong>without a discontinuous cliff</strong> (unlike hard clipping).</li>
</ul>
<p>This is why the paper calls SAPO a <strong>continuous trust region</strong>: the “trust” shrinks continuously as deviation grows, rather than flipping from 1 to 0 at a fixed $\epsilon$.</p>
<p><strong>Why SAPO uses two different temperatures $\tau_{\text{pos}}$​ and $\tau_{\text{neg}}$?</strong></p>
<p><strong>Negative-advantage token updates are intrinsically more destabilizing in large-vocabulary softmax policies</strong>, because their gradients spread across <em>many</em> logits (many “unsampled” tokens). So SAPO makes negative-token gates decay faster by setting $\tau_{\text{neg}}&gt;\tau_{\text{pos}}$.</p>
<p>​<strong>​Mathematical Intuition</strong>:</p>
<p>Let the model output logits $z \in \mathbb{R}^{|V|}$ at a decoding step $t$, where $z_v$​ is the logit for vocabulary token $v$. The policy is a softmax:</p>
<p>$$
\pi _ \theta(v \mid q, y _ {&lt;t}) = \frac{e^{z _ v}}{\sum _ {v&rsquo;\in V} e^{z _ v&rsquo;}}.
$$</p>
<p>A sampled token at this step is $y_t$​ (the action taken). In policy-gradient RL, you weight the log-prob gradient by an advantage $\hat A_t$ (or $\hat A_i$ shared across tokens in a sequence):</p>
<p>$$
\text{token contribution} \propto \hat A_t , \nabla_\theta \log \pi_\theta(y_t \mid q,y_{&lt;t}).
$$</p>
<p>We want $\frac{\partial}{\partial z_v} \big(\hat A_t \log \pi_\theta(y_t)\big)$.</p>
<p>First recall the standard softmax-log derivative:</p>
<p>$$
\frac{\partial \log \pi _ \theta(y _ t)}{\partial z _ v} = \mathbf{1}[v = y _ t] - \pi _ \theta(v).
$$</p>
<p>Multiply by $\hat A_t$​:</p>
<p>$$
\frac{\partial \log \pi _ \theta\left(y _ {i,t}\mid q, y _ {i,&lt;t}\right),\hat A _ {i,t}}{\partial z _ v} = \frac{\partial \pi _ \theta\left(y _ {i,t}\mid q, y _ {i,&lt;t}\right)}{\partial z _ v}\cdot \frac{\hat A _ {i,t}}{\pi _ \theta\left(y _ {i,t}\mid q, y _ {i,&lt;t}\right)}
$$</p>
<p>$$
= \frac{ \mathbf{1}( v = y _ { i,t } ) \cdot e ^ { z _ { y _ { i,t } } } \sum _ { v&rsquo; \in V } e ^ { z _ { v&rsquo; } } - e ^ { z _ { y _ { i,t } } } \cdot e ^ { z _ v } }{ ( \sum _ { v&rsquo; \in V } e ^ { z _ { v&rsquo; } } ) ^ 2 } \cdot \frac{ \hat{A} _ { i,t } }{ \pi _ \theta ( y _ { i,t } | q, y _ { i,&lt;t } ) }
$$</p>
<ul>
<li>
<p><strong>For the Sampled Token ($v = y _ { i,t }$):</strong>
$$
\text{Gradient} = ( 1 - \pi _ \theta ( y _ { i,t } | q , y _ { i,&lt;t } ) ) \cdot \hat{A} _ { i,t }
$$</p>
</li>
<li>
<p><strong>For All Other Tokens ($v \neq y _ { i,t }$):</strong>
$$
\text{Gradient} = - \pi _ \theta ( v | q , y _ { i,&lt;t } ) \cdot \hat{A} _ { i,t }
$$</p>
</li>
</ul>
<ul>
<li>$\mathbf{1}[v=y_t]$: indicator for the sampled token.</li>
<li>$\pi_\theta(v)$: model’s probability mass on token $v$ at this state.</li>
<li>$\hat A_t$: advantage; sign determines whether to reinforce or suppress the sampled action.</li>
</ul>
<p><strong>Intuition: positive vs. negative advantages change the <em>direction</em> of mass movement</strong></p>
<p><strong>Case A: $\hat A_t &gt; 0$ (positive advantage)</strong></p>
<p>For the sampled token $v=y_t$​:
$$
\Delta z_{y_t} \propto (1-\pi_\theta(y_t)),\hat A_t &gt; 0
$$
So we <strong>increase</strong> the sampled token’s logit (make it more likely).</p>
<p>For every other token $v\neq y_t$​:
$$
\Delta z_v \propto -\pi_\theta(v)\hat A_t &lt; 0
$$
So we <strong>decrease</strong> all other logits slightly.</p>
<p><strong>Net effect:</strong> probability mass flows <em>toward the sampled token</em>.</p>
<p><strong>Case B: $\hat A_t &lt; 0$ (negative advantage)</strong></p>
<p>Now signs flip.</p>
<p>For the sampled token:</p>
<p>$$
\Delta z_{y_t} \propto (1-\pi_\theta(y_t))\hat A_t &lt; 0
$$</p>
<p>So we <strong>decrease</strong> the sampled token’s logit (make it less likely).</p>
<p>For every other token:
$$
\Delta z_v \propto -\pi_\theta(v)\hat A_t &gt; 0
$$</p>
<p>So we <strong>increase</strong> logits of <em>all other tokens</em>.</p>
<p><strong>Net effect:</strong> probability mass is pushed <em>away from the sampled token</em> and spread across the rest of the vocabulary.</p>
<p><strong>Why negative updates are more destabilizing in LLMs?</strong></p>
<p>In LLM RL, the action space is the vocabulary: $|V|$ is huge (often $10^5–10^6$). At a given state, only a small subset of tokens are “reasonable.” The paper’s point is:</p>
<ul>
<li>With <strong>negative advantage</strong>, you are <em>increasing</em> logits for an enormous set of “unsampled” tokens.</li>
<li>Even though each individual increase is scaled by $\pi_\theta(v)$, there are so many $v\neq y_t$ that the update can “diffuse” into lots of irrelevant directions.</li>
<li>This diffusion is especially harmful <strong>off-policy</strong> (importance ratios far from 1), where variance is already high.</li>
</ul>
<p>You can see this from the total “push” to unsampled logits:</p>
<p>$$
\sum_{v\neq y_t} \Delta z_v \propto \sum_{v\neq y_t} \big(-\pi_\theta(v)\hat A_t\big)
= -(1-\pi_\theta(y_t))\hat A_t.
$$</p>
<p>So the <em>aggregate</em> magnitude is comparable to the sampled-token magnitude, but it’s distributed over $|V|-1$ coordinates, i.e., a very high-dimensional “spray.” For $\hat A_t&lt;0$, that spray points in a direction that can introduce instability (lots of tiny increases to many logits can change the distribution in unintuitive ways, especially under large steps / off-policy noise).</p>
<p><strong>How SAPO uses temperature to tame this: $\tau_{\text{neg}} &gt; \tau_{\text{pos}}$</strong></p>
<p>SAPO’s token gate uses a temperature $\tau$ that controls <strong>how fast gradients decay</strong> as the importance ratio $r_{t}​$ deviates from 1. The effective weight is a smooth kernel that peaks at $r=1$ and shrinks as $|r-1|$ grows:</p>
<p>$$
w(r) = 4\sigma(\tau(r-1))\big(1-\sigma(\tau(r-1))\big)
= \mathrm{sech}^2\left(\frac{\tau}{2}(r-1)\right).
$$</p>
<ul>
<li>
<p>Larger $\tau$ ⇒ <strong>faster decay</strong> of $w(r)$ away from $r=1$ (more aggressive damping of off-policy tokens).</p>
</li>
<li>
<p>SAPO sets:</p>
</li>
</ul>
<ul>
<li>
<p><strong>Positive Advantage ($\hat{A} _ t &gt; 0$):</strong>
$$
\tau = \tau _ { \text{pos} }
$$</p>
</li>
<li>
<p><strong>Negative Advantage ($\hat{A} _ t \le 0$):</strong>
$$
\tau = \tau _ { \text{neg} }
$$</p>
</li>
</ul>
<p><strong>Constraint:</strong>
$$
\tau _ { \text{neg} } &gt; \tau _ { \text{pos} }
$$</p>
<p>So when $\hat A_t&lt;0$, the update is the “spray to unsampled logits” case, and SAPO <strong>attenuates it more strongly</strong> as soon as it becomes off-policy, reducing variance and early collapse risk.</p>
<p>SAPO/GRPO/GSPO can be written as a <strong>single gated surrogate</strong> (unified-surrogate) where the only difference is the <em>gating function</em> $f_{i,t}$​:</p>
<p>$$
\mathcal{J}(\theta)
=\mathbb{E}\Bigg[\frac{1}{G}\sum_{i=1}^G \frac{1}{|y_i|}\sum_{t=1}^{|y_i|}
f_{i,t}\big(r_{i,t}(\theta)\big)\hat A_{i,t}\Bigg],
\qquad
r_{i,t}(\theta)=\frac{\pi_\theta(y_{i,t}\mid q,y_{i,&lt;t})}{\pi_{\theta_{\text{old}}}(y_{i,t}\mid q,y_{i,&lt;t})}.
$$</p>
<p>where, $f_{i,t}(·)$ is an algorithm-specific gating function.</p>
<p>GSPO is “sequence-level” because it replaces token ratios by the <strong>length-normalized sequence ratio</strong> (geometric mean):</p>
<p>$$
s_i(\theta)
=\left(\frac{\pi_\theta(y_i\mid q)}{\pi_{\theta_{\text{old}}}(y_i\mid q)}\right)^{1/|y_i|}
=\exp\left(\frac{1}{|y_i|}\sum_{t=1}^{|y_i|}\log r_{i,t}(\theta)\right),
$$</p>
<p>and then gates using $s_i(\theta)$ (token-invariant within a sequence), while GRPO gates each token via hard clipping of $r_{i,t}$​. SAPO instead uses a <strong>soft gate</strong>:</p>
<p>$$
f^{\text{SAPO}} _ {i,t}(r)=\frac{4}{\tau _ i}\sigma\big(\tau _ i(r-1)\big),\qquad \tau _ i=\tau _ {\text{pos}}\ \text{if }\hat A _ i&gt;0,\ \text{else }\tau _ {\text{neg}},
$$</p>
<p>so its gradient contribution is smoothly down-weighted as $r$ moves away from the on-policy point $r=1$, rather than being abruptly zeroed by a hard clip.</p>
<p><strong>Algorithm-specific $f _ {i,t}$</strong>.</p>
<p>The algorithms differ in the choice of $f _ {i,t}$:</p>
<p>$$ \textbf{SAPO:}\quad f^{\mathrm{SAPO}} _ {i,t}\big(r _ {i,t}(\theta)\big) = \frac{4}{\tau _ i}\sigma\big(\tau _ i,(r _ {i,t}(\theta)-1)\big), \qquad \tau _ i= \begin{cases} \tau _ {\text{pos}}: &amp; \hat A _ i&gt;0,\
\tau _ {\text{neg}}: &amp; \hat A _ i\le 0.
\end{cases}
$$</p>
<p>$$
\textbf{GRPO:}\quad f^{\mathrm{GRPO}} _ {i,t}\big(r _ {i,t}(\theta);\hat A _ i\big) = \begin{cases} \min\big(r _ {i,t}(\theta),1+\epsilon\big): &amp; \hat A _ i&gt;0,\ \max\big(r _ {i,t}(\theta),1-\epsilon\big): &amp; \hat A _ i\le 0.
\end{cases}
$$</p>
<p>$$
\textbf{GSPO:}\quad f^{\mathrm{GSPO}} _ {i,t}\big(r _ {i,t}(\theta);\hat A _ i\big) = f^{\mathrm{seq}} _ {i,t}\big(s _ i(\theta);\hat A _ i\big) = \begin{cases} \min\big(s _ i(\theta),1+\epsilon\big): &amp; \hat A _ i&gt;0,\ \max\big(s _ i(\theta),1-\epsilon\big): &amp; \hat A _ i\le 0.
\end{cases}
$$</p>
<p>GSPO’s $f_{i,t}$ is token-invariant within a sequence, while SAPO and GRPO are token-dependent.</p>
<p>Differentiating the unified surrogate gives the common “gate × ratio × logprob-grad × advantage” form:
$$
\nabla _ \theta \mathcal{J}(\theta) =\mathbb{E}\Bigg[\frac{1}{G}\sum _ {i=1}^G \frac{1}{|y _ i|}\sum _ {t=1}^{|y _ i|}
f&rsquo; _ {i,t}\big(r _ {i,t}(\theta)\big)\ r _ {i,t}(\theta)\ \nabla _ \theta\log\pi _ \theta(y _ {i,t}\mid q,y _ {i,&lt;t})\hat A _ {i,t}\Bigg].
$$</p>
<p>For SAPO specifically, using $\sigma(x)(1-\sigma(x))=\tfrac14\mathrm{sech}^2(x/2)$:</p>
<p>$$
f _ {i,t}^{\mathrm{SAPO}'}\big(r _ {i,t}(\theta)\big) = 4\sigma\big(\tau _ i(r _ {i,t}(\theta)-1)\big)\Big(1-\sigma\big(\tau _ i(r _ {i,t}(\theta)-1)\big)\Big) = \mathrm{sech}^2\left(\frac{\tau _ i}{2}\big(r _ {i,t}(\theta)-1\big)\right).
$$</p>
<p>The post-training landscape is clearly past the era of “just use PPO.” What GRPO and its descendants have exposed is a deeper pattern: most of the practical wins come from <strong>how we control trust and variance</strong> in the update, where the trust region lives (token vs. sequence), how sharply we enforce it (hard clip vs. soft gate), and how we keep exploration alive without letting off-policy noise and long-horizon credit assignment blow up the run.  The “algorithm” is increasingly a choice of <strong>gating function, normalization scheme, and stability knobs</strong> tailored to the geometry of language modeling, huge vocabularies, long sequences, and a reward signal that’s sparse, delayed, and often noisy.</p>
<p>If there’s one takeaway to carry forward, it’s that the next wave of progress will come less from inventing yet another acronym and more from making these design axes explicit and measurable. As you experiment, treat these methods as a toolkit: pick the gate that matches your reward structure, pick the unit of coherence that matches your objective (token-local vs. sequence-global), and tune conservativeness in a way you can defend with plots. The exciting part is that we’re still early: as verifiable rewards, multimodal policies, and long-context training become standard, these “small” choices about clipping, gating, and variance control are going to be the difference between models that merely improve and systems that train reliably at scale.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ol>
<li><a href="https://arxiv.org/abs/1707.06347">Proximal Policy Optimization Algorithms</a></li>
<li><a href="https://arxiv.org/abs/2402.03300">DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models</a></li>
<li><a href="https://arxiv.org/pdf/2412.19437">DeepSeek-V3 Technical Report</a></li>
<li><a href="https://arxiv.org/abs/2503.20783">Understanding R1-Zero-Like Training: A Critical Perspective</a></li>
<li><a href="https://arxiv.org/abs/2507.18071">Group Sequence Policy Optimization</a></li>
<li><a href="https://arxiv.org/abs/2503.14476">DAPO: An Open-Source LLM Reinforcement Learning System at Scale</a></li>
<li><a href="https://arxiv.org/pdf/2506.13585">MiniMax-M1: Scaling Test-Time Compute Efficiently with Lightning Attention</a></li>
<li><a href="https://arxiv.org/abs/2507.20673">Geometric-Mean Policy Optimization</a></li>
<li><a href="https://www.alphaxiv.org/abs/2510.23027">Towards Stable and Effective Reinforcement Learning for MoEs</a></li>
<li><a href="https://arxiv.org/abs/2511.20347?spm=a2ty_o06.30285417.0.0.3107c921VbuzgU&amp;file=2511.20347">Soft Adaptive Policy Optimization</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/post-training/">Post-Training</a></li>
      <li><a href="http://localhost:1313/tags/rlhf/">RLHF</a></li>
      <li><a href="http://localhost:1313/tags/policy-optimization/">Policy Optimization</a></li>
      <li><a href="http://localhost:1313/tags/reinforcement-learning/">Reinforcement Learning</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">yadnyesh&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
