<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Go With The Flow | yadnyesh&#39;s blog</title>
<meta name="keywords" content="image generation, flow matching, normalizing flows, rectified flows, stable diffusion">
<meta name="description" content="Flow-based generative models are starting to turn heads as a cool alternative to traditional diffusion methods for things like image and audio generation. What makes them stand out is how they learn smooth, efficient paths to transform one distribution into another—basically a neat and mathematically solid way to generate data. They’ve been getting a lot more buzz lately, especially after Black Forest Labs dropped their FLUX models and SD3.5 model by Stability AI. That success has brought fresh attention to the earlier ideas behind Rectified Flows, which first popped up at ICLR 2023.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/go_with_the_flow/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css" integrity="sha256-bammPSWpYIvKL3&#43;QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/go_with_the_flow/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  });">
</script>


</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="yadnyesh&#39;s blog (Alt + H)">yadnyesh&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/readinglist/" title="Reading List">
                    <span>Reading List</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Go With The Flow
    </h1>
    <div class="post-meta"><span title='2025-04-27 12:34:29 +0530 IST'>April 27, 2025</span>&nbsp;·&nbsp;24 min

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#so-whats-a-flow" aria-label="So What’s a Flow?">So What’s a Flow?</a></li>
                <li>
                    <a href="#a-quick-linear-algebra-refresher" aria-label="A Quick Linear Algebra Refresher">A Quick Linear Algebra Refresher</a></li>
                <li>
                    <a href="#normalizing-flows" aria-label="Normalizing Flows">Normalizing Flows</a><ul>
                        
                <li>
                    <a href="#why-are-normalizing-flows-called-normalizing-flows" aria-label="Why Are Normalizing Flows Called &ldquo;Normalizing&rdquo; Flows?">Why Are Normalizing Flows Called &ldquo;Normalizing&rdquo; Flows?</a></li>
                <li>
                    <a href="#exact-log-likelihoods-with-normalizing-flows" aria-label="Exact Log-Likelihoods with Normalizing Flows">Exact Log-Likelihoods with Normalizing Flows</a><ul>
                        
                <li>
                    <a href="#variational-autoencoders-vaes" aria-label="Variational Autoencoders (VAEs)">Variational Autoencoders (VAEs)</a></li>
                <li>
                    <a href="#generative-adversarial-networks-gans" aria-label="Generative Adversarial Networks (GANs)">Generative Adversarial Networks (GANs)</a></li>
                <li>
                    <a href="#normalizing-flows-1" aria-label="Normalizing Flows">Normalizing Flows</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#flow-matching---a-deep-dive" aria-label="Flow Matching - A Deep Dive">Flow Matching - A Deep Dive</a><ul>
                        <ul>
                        
                <li>
                    <a href="#note-flow-and-diffusion-models" aria-label="Note: Flow and Diffusion Models">Note: Flow and Diffusion Models</a></li>
                <li>
                    <a href="#flow-model" aria-label="Flow Model">Flow Model</a></li>
                <li>
                    <a href="#diffusion-model" aria-label="Diffusion Model">Diffusion Model</a></li></ul>
                    
                <li>
                    <a href="#constructing-the-training-target-for-flow-models" aria-label="Constructing the Training Target for Flow Models">Constructing the Training Target for Flow Models</a></li>
                <li>
                    <a href="#conditional-probability-path" aria-label="Conditional Probability Path">Conditional Probability Path</a></li>
                <li>
                    <a href="#conditional-vector-field" aria-label="Conditional Vector Field">Conditional Vector Field</a></li>
                <li>
                    <a href="#marginal-probability-path" aria-label="Marginal Probability Path">Marginal Probability Path</a></li>
                <li>
                    <a href="#marginal-vector-field" aria-label="Marginal Vector Field">Marginal Vector Field</a></li>
                <li>
                    <a href="#conditional--marginal-score-function" aria-label="Conditional &amp; Marginal Score Function">Conditional &amp; Marginal Score Function</a><ul>
                        
                <li>
                    <a href="#1-conditional-score" aria-label="1. Conditional Score">1. Conditional Score</a></li>
                <li>
                    <a href="#2-marginal-score" aria-label="2. Marginal Score">2. Marginal Score</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#flow-matching" aria-label="Flow Matching">Flow Matching</a><ul>
                        
                <li>
                    <a href="#flow-matching-loss" aria-label="Flow Matching Loss">Flow Matching Loss</a></li>
                <li>
                    <a href="#conditional-flow-matching-loss" aria-label="Conditional Flow Matching Loss">Conditional Flow Matching Loss</a></li>
                <li>
                    <a href="#key-consequences" aria-label="Key Consequences">Key Consequences</a></li>
                <li>
                    <a href="#flow-matching-training-procedure-general" aria-label="Flow Matching Training Procedure (General)">Flow Matching Training Procedure (General)</a></li>
                <li>
                    <a href="#flow-matching-training-for-condot-optimal-transport-path" aria-label="Flow Matching Training for CondOT (Optimal Transport) Path">Flow Matching Training for CondOT (Optimal Transport) Path</a></li></ul>
                </li>
                <li>
                    <a href="#rectified-flows" aria-label="Rectified Flows">Rectified Flows</a><ul>
                        
                <li>
                    <a href="#learning-transport-maps" aria-label="Learning Transport Maps">Learning Transport Maps</a></li>
                <li>
                    <a href="#why-is-finding-a-transport-map-challenging" aria-label="Why is Finding a Transport Map Challenging?">Why is Finding a Transport Map Challenging?</a></li>
                <li>
                    <a href="#optimal-transport-ot" aria-label="Optimal Transport (OT)">Optimal Transport (OT)</a></li>
                <li>
                    <a href="#method-rectified-flow" aria-label="Method: Rectified Flow">Method: Rectified Flow</a></li>
                <li>
                    <a href="#why-straight-paths" aria-label="Why Straight Paths?">Why Straight Paths?</a></li>
                <li>
                    <a href="#how-rectified-flow-works" aria-label="How Rectified Flow Works">How Rectified Flow Works</a></li>
                <li>
                    <a href="#solution-causalizing-the-interpolation" aria-label="Solution: Causalizing the Interpolation">Solution: Causalizing the Interpolation</a></li>
                <li>
                    <a href="#key-properties-of-rectified-flow" aria-label="Key Properties of Rectified Flow">Key Properties of Rectified Flow</a></li>
                <li>
                    <a href="#reflow-fast-generation-with-straight-flows" aria-label="Reflow: Fast Generation with Straight Flows">Reflow: Fast Generation with Straight Flows</a></li>
                <li>
                    <a href="#key-properties" aria-label="Key Properties">Key Properties</a></li></ul>
                </li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Flow-based generative models are starting to turn heads as a cool alternative to traditional diffusion methods for things like image and audio generation. What makes them stand out is how they learn smooth, efficient paths to transform one distribution into another—basically a neat and mathematically solid way to generate data. They’ve been getting a lot more buzz lately, especially after Black Forest Labs dropped their <a href="https://bfl.ai/models/flux-pro">FLUX</a> models and <a href="https://stability.ai/news/introducing-stable-diffusion-3-5">SD3.5</a> model by Stability AI. That success has brought fresh attention to the earlier ideas behind Rectified Flows, which first popped up at ICLR 2023.</p>
<p>This wave of renewed interest is pushing researchers to rethink how we model generative processes—not just as noisy reversals but as guided, purposeful flows through data space. Unlike diffusion models that slowly denoise data step by step, flow-based models aim to learn the exact path from noise to structure in one go, which can make generation faster and more controllable. Plus, with growing support from recent papers and open-source projects, it’s becoming easier for developers and researchers to experiment with these models and push them into new creative and scientific applications.</p>
<h2 id="so-whats-a-flow">So What’s a Flow?<a hidden class="anchor" aria-hidden="true" href="#so-whats-a-flow">#</a></h2>
<p>Imagine you&rsquo;re watching a river flow downstream. At every point, the water has a direction and speed—it’s not just sitting still. Now picture a tiny leaf floating on that river. As time passes, the river carries the leaf smoothly along a path. That motion—the direction the leaf moves at each point in time—is what we’d call a <strong>flow</strong>.</p>
<p><img alt="Flow Intuition" loading="lazy" src="/images/Flow_Visualized.jpeg"></p>
<p>In the world of generative AI, we can think of <strong>data points</strong> like that little leaf, and <strong>the flow</strong> is a kind of invisible force field that guides how we transform one kind of data (say, pure noise) into another (like a realistic image). Instead of just jumping from noise to image, the model learns how to <em>gradually</em> reshape the randomness into structure, just like the river reshapes the leaf’s position as it moves.</p>
<p>So, just like in a river or a gust of wind, every point in space has a little arrow—a velocity vector—that tells tiny particles where to move. And just like how water currents or wind patterns can change over time and space, our model’s “flow field” can also depend on both position and time.</p>
<p>Flow matching taps into this idea by trying to learn those natural movement patterns. It’s like asking at every moment, “If this data point were a leaf on a river, which direction should it drift right now?” The model doesn’t just guess the final destination—it learns the smooth path each point should follow through the data space.</p>
<h2 id="a-quick-linear-algebra-refresher">A Quick Linear Algebra Refresher<a hidden class="anchor" aria-hidden="true" href="#a-quick-linear-algebra-refresher">#</a></h2>
<p>Before we dive deeper into the mathematical intuition behind flows and how flow-based models actually work, let’s hit pause and take a quick detour to understand what is a Jacobian and the Change of Variables theorem.</p>
<p>Given a function of mapping a $n$-dimensional input vector $\mathbf{x}$ to a $m$-dimensional output vector, $f : \mathbb{R}^n \mapsto \mathbb{R}^m$, the matrix of all first-order partial derivatives of this function is called the <strong>Jacobian matrix</strong>, $\mathbf{J}$, where one entry on the $i$-th row and $j$-th column is<br>
$$
\mathbf{J}_{ij} = \frac{\partial f_i}{\partial x_j}
$$
The Jacobian matrix looks like:
$$
J =
\begin{bmatrix}
\displaystyle \frac{\partial f_1}{\partial x_1} &amp; \cdots &amp; \displaystyle \frac{\partial f_1}{\partial x_n} \
\vdots &amp; \ddots &amp; \vdots \
\displaystyle \frac{\partial f_m}{\partial x_1} &amp; \cdots &amp; \displaystyle \frac{\partial f_m}{\partial x_n}
\end{bmatrix}
$$</p>
<p>The <strong>Jacobian</strong> tells us how a function transforms space locally—it shows how small changes in input affect each output. It acts like a map of sensitivities and stretching, and its determinant measures how much the function expands or contracts space at a point.</p>
<p><img alt="Jacobian Intuition" loading="lazy" src="/images/Jacobian_Intuition.png"></p>
<p>The <strong>determinant</strong> is a single number that summarizes certain properties of a square matrix.  You can only compute it for <strong>square matrices</strong>—that is, matrices with the same number of rows and columns.</p>
<p>At a high level, the determinant tells us how much a matrix <em>stretches or squashes space</em>.<br>
You can think of it as measuring the &ldquo;volume change&rdquo; caused by the matrix when it transforms data.
For an $n \times n$ matrix $M$, the determinant is calculated as:</p>
<p>$$
\det M =
\begin{vmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{vmatrix}
= \sum_{j_1 j_2 \cdots j_n} (-1)^{\tau(j_1 j_2 \cdots j_n)} a_{1j_1} a_{2j_2} \cdots a_{nj_n}
$$</p>
<p>This sum runs over all possible permutations of column indices $j_1, j_2, \dots, j_n$.<br>
The function $\tau(\cdot)$ gives the <strong>sign</strong> of each permutation (+1 or -1), depending on how &ldquo;twisted&rdquo; it is.</p>
<p><strong>Why is the determinant useful?</strong></p>
<ul>
<li>If $\det(M) = 0$, the matrix <strong>flattens space</strong> in some direction—it’s not reversible. This means the matrix is <strong>not invertible</strong> (it’s <em>singular</em>).</li>
<li>If $\det(M) \ne 0$, then the matrix <strong>preserves some volume</strong>, and is <strong>invertible</strong>.</li>
</ul>
<p>A neat property of determinants:<br>
If you multiply two square matrices, their determinants also multiply:</p>
<p>$$
\det(AB) = \det(A) \cdot \det(B)
$$</p>
<p><strong>Change of Variables Theorem (for Density Estimation)</strong></p>
<p>At it&rsquo;s core Change of Variable theorem tells us how a probability density changes when you transform the variable it&rsquo;s defined on.</p>
<p>Let’s go over the <strong>change of variable theorem</strong> in the context of probability density estimation, starting with the simple case of a single variable.</p>
<p><strong>One-Dimensional Case</strong></p>
<p>Suppose we have a random variable $z$ with known density $\pi(z)$, and we define a new variable $x = f(z)$ using a 1-to-1 invertible function $f$.  This means $z = f^{-1}(x)$.<br>
Now we want to find the unknown density of $x$, denoted $p(x)$.</p>
<p>Using the fact that probabilities must sum to 1:</p>
<p>$$
\int p(x) \ dx = \int \pi(z) \ dz = 1
$$</p>
<p>To convert densities between variables, we apply the change of variables formula:</p>
<p>$$
p(x) = \pi(z) \left| \frac{dz}{dx} \right|
= \pi(f^{-1}(x)) \left| \frac{d f^{-1}}{dx} \right|
= \pi(f^{-1}(x)) \left| (f^{-1})&rsquo;(x) \right|
$$</p>
<p>Here, $\left| \frac{df^{-1}}{dx} \right|$ captures how the space is stretched or squashed during transformation.</p>
<p>Think of the integral $\int \pi(z) , dz$ as adding up many thin rectangles. Each rectangle has Width $\Delta z$ and Height $\pi(z)$. When we substitute $z = f^{-1}(x)$, we’re essentially changing the coordinates.  The width becomes:$$
\Delta z = \left( f^{-1}(x) \right)&rsquo; \Delta x
$$So, the scaling factor $\left| (f^{-1}(x))&rsquo; \right|$ tells us how the density stretches when changing variables.</p>
<p><strong>Multivariable Case</strong></p>
<p>For higher dimensions, the concept extends using the <strong>Jacobian determinant</strong>.</p>
<p>Let:
$$
z \sim \pi(z), \quad x = f(z), \quad z = f^{-1}(x)
$$</p>
<p>Then the density transforms as:</p>
<p>$$
p(x) = \pi(z) \left| \det \frac{dz}{dx} \right|
= \pi(f^{-1}(x)) \left| \det \frac{d f^{-1}}{dx} \right|
$$</p>
<p>Here, $\det \frac{\partial f}{\partial x}$ is the <strong>Jacobian determinant</strong> of the function $f$.</p>
<h2 id="normalizing-flows">Normalizing Flows<a hidden class="anchor" aria-hidden="true" href="#normalizing-flows">#</a></h2>
<p><em>Normalizing Flows</em> is a method for turning a simple probability distribution (like a Gaussian) into a complex one by applying a sequence of invertible and differentiable transformations.</p>
<p><img alt="Normalizing Flow" loading="lazy" src="/images/Normalizing_Flow.jpeg"></p>
<p>Normalizing Flows learn an <em>invertible</em> mapping  $f: \mathcal{X} \rightarrow \mathcal{Z}$ ; where $\mathcal{X}$ is the data distribution and $\mathcal{Z}$ is a chosen latent distribution.</p>
<p>Let:</p>
<p>$$
x = f_\theta(z) = f_k \circ \cdots \circ f_2 \circ f_1(z)
$$</p>
<p>where each $f_i$ is invertible (bijective).</p>
<p>We define:</p>
<p>$$
f: \mathcal{Z} \rightarrow \mathcal{X}, \quad \text{where } f \text{ is invertible}
$$</p>
<p>Let $p_\theta(x)$ be the probability density over $x$, with $z \in \mathcal{Z}$.</p>
<p><img alt="Inverse" loading="lazy" src="/images/Inverse.jpeg"></p>
<p>Change of Variable Formula:</p>
<p>$$
p_\theta(x) = p_\theta(f^{-1}(x)) \left| \det \left( \frac{\partial f^{-1}(x)}{\partial x} \right) \right|
$$</p>
<p>If we replace $f^{-1}(x)$ with $z$, the formula becomes:</p>
<p>$$
p_\theta(x) = p_\theta(z) \left| \det \left( \frac{\partial z}{\partial x} \right) \right|
$$ Finally:</p>
<p>$$
p_\theta(x) = p_\theta(z) \prod_{i=1}^{k} \left| \det \left( \frac{\partial f_i^{-1}}{\partial z_i} \right) \right|
= p_\theta(z) \left| \det \left( \frac{\partial f^{-1}}{\partial x} \right) \right|
$$</p>
<p>The sequence of transformations applied to random variables, expressed as:</p>
<p>$$
z_i = f_i(z_{i-1})
$$</p>
<p>is called the <strong>flow</strong>. When this sequence forms a chain of distributions $\pi_i$, the entire process is referred to as a <strong>normalizing flow</strong>.
For each transformation function $f_i$ in the flow to be usable in practice, it must meet two key criteria:</p>
<ol>
<li>It must be <strong>easily invertible</strong>.</li>
<li>Its <strong>Jacobian determinant</strong> must be <strong>efficient to compute</strong>.</li>
</ol>
<p><img alt="Flow Comparison" loading="lazy" src="/images/Flow_Comparison.png"></p>
<h3 id="why-are-normalizing-flows-called-normalizing-flows">Why Are Normalizing Flows Called &ldquo;Normalizing&rdquo; Flows?<a hidden class="anchor" aria-hidden="true" href="#why-are-normalizing-flows-called-normalizing-flows">#</a></h3>
<p><strong>Normalizing Flows</strong> refer to the process of transforming probability distributions <strong>while preserving normalization</strong>—i.e., ensuring they remain valid probability distributions.
The <strong>change of variables formula</strong> ensures that the <strong>probability density</strong> is adjusted (or “normalized”) correctly during this transformation. This adjustment is what allows the transformed distribution to stay normalized—hence the name <strong>&ldquo;Normalizing Flows&rdquo;</strong>.</p>
<h3 id="exact-log-likelihoods-with-normalizing-flows">Exact Log-Likelihoods with Normalizing Flows<a hidden class="anchor" aria-hidden="true" href="#exact-log-likelihoods-with-normalizing-flows">#</a></h3>
<p>One of the key advantages of <strong>Normalizing Flows</strong> is that they allow us to compute <em><strong>exact log-likelihoods</strong></em>, which is rare for most generative models.</p>
<h4 id="variational-autoencoders-vaes">Variational Autoencoders (VAEs)<a hidden class="anchor" aria-hidden="true" href="#variational-autoencoders-vaes">#</a></h4>
<ul>
<li>Provide only a <strong>lower bound</strong> on the log-likelihood (<a href="https://en.wikipedia.org/wiki/Evidence_lower_bound">ELBO</a>).</li>
<li>Use an <strong>approximate posterior</strong> $q_\phi(z \mid x)$</li>
</ul>
<h4 id="generative-adversarial-networks-gans">Generative Adversarial Networks (GANs)<a hidden class="anchor" aria-hidden="true" href="#generative-adversarial-networks-gans">#</a></h4>
<ul>
<li>Do <strong>not</strong> support log-likelihood evaluation.</li>
<li>Do <strong>not</strong> provide latent variable inference.</li>
</ul>
<h4 id="normalizing-flows-1">Normalizing Flows<a hidden class="anchor" aria-hidden="true" href="#normalizing-flows-1">#</a></h4>
<p>With normalizing flows, we can compute:</p>
<p>$$
\log p_\theta(x) = \log p_\theta(z) + \sum_{i=1}^K \log \left| \det \left( \frac{\partial f_i^{-1}}{\partial z_i} \right) \right|
$$</p>
<ul>
<li>Allows for <strong><em>exact log-likelihood</em> evaluation</strong>.</li>
<li>Also enables <em><strong>exact posterior inference</strong></em> via the invertible transformation $z = f^{-1}(x)$</li>
</ul>
<p><img alt="GAN/VAE/FLOW" loading="lazy" src="/images/GAN_VAE_Flow.png"></p>
<h2 id="flow-matching---a-deep-dive">Flow Matching - A Deep Dive<a hidden class="anchor" aria-hidden="true" href="#flow-matching---a-deep-dive">#</a></h2>
<p>Given a training dataset sampled from a target distribution $q$ over $\mathbb{R}^d$, the goal is to learn a generative model that can produce new samples from $q$.
To achieve this, <strong>Flow Matching (FM)</strong> constructs a <em><strong>probability path</strong></em> $(p_t)_{0 &lt; t &lt; 1}$ that transitions from a known source distribution $p_0 = p$ to the target distribution $p_1 = q$, where each $p_t$ is a distribution over $\mathbb{R}^d$.</p>
<p>Flow Matching works by training a <em><strong>velocity field</strong></em>—a neural network that estimates the instantaneous velocity of samples along this path. This field is later used to transport samples from the source $p_0$ to the target $p_1$ by solving a differential equation.</p>
<p>After training, generating a new sample from the target distribution $X_1 \sim q$ involves:</p>
<ol>
<li>Sampling an initial point $X_0 \sim p$, and</li>
<li>Solving the<a href="https://en.wikipedia.org/wiki/Ordinary_differential_equation"> <strong>Ordinary Differential Equation (ODE)</strong></a> guided by the learned velocity field.</li>
</ol>
<p>Why to solve the ODE? Given a starting point $X_0$ ODE tells you how to move it to $X_1$.</p>
<p>A flow $\psi_t : \mathbb{R}^d \rightarrow \mathbb{R}^d$ (represented by the square grid) is defined through a velocity field $u_t : \mathbb{R}^d \rightarrow \mathbb{R}^d$, visualized here using blue arrows. This velocity field dictates how every point moves <em>instantaneously</em> across space. The three images illustrate how the grid is progressively deformed at different time steps $t$.</p>
<p><img alt="Flow Graph" loading="lazy" src="/images/Flow_Graph.png"></p>
<p>The objective of <strong>generative flow modeling</strong> is to learn a flow $\psi_t$ such that:</p>
<p>$$
X_1 = \psi_1(X_0) \sim q,
$$</p>
<p>where $X_0$ is sampled from a simple source distribution (e.g., Gaussian), and $q$ is the target data distribution.</p>
<h4 id="note-flow-and-diffusion-models">Note: Flow and Diffusion Models<a hidden class="anchor" aria-hidden="true" href="#note-flow-and-diffusion-models">#</a></h4>
<p>Both <strong>Flow Models</strong> and <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/"><strong>Diffusion Models</strong></a> generate samples by <em>evolving</em> a random variable over time, starting from a simple initial distribution.</p>
<h4 id="flow-model">Flow Model<a hidden class="anchor" aria-hidden="true" href="#flow-model">#</a></h4>
<p>Initialize:<br>
$$ X_0 \sim p_{\text{init}} \quad \text{(e.g., Gaussian)} $$
Evolve using an ODE:<br>
$$ dX_t = u_t^\theta(X_t)\ dt $$</p>
<ul>
<li>$u_t^\theta$ is a neural network that defines a time-dependent <strong>vector field</strong>.</li>
<li>The evolution is <em><strong>deterministic</strong></em> (no randomness).</li>
</ul>
<h4 id="diffusion-model">Diffusion Model<a hidden class="anchor" aria-hidden="true" href="#diffusion-model">#</a></h4>
<p>Initialize:<br>
$$ X_0 \sim p_{\text{init}} $$
Evolve using an SDE:
$$ dX_t = u_t^\theta(X_t)\ dt + \sigma_t\ dW_t $$</p>
<ul>
<li>$u_t^\theta$ is again a neural network vector field.</li>
<li>$\sigma_t$ is the <em><strong>diffusion coefficient</strong></em>.</li>
<li>$dW_t$ is a <a href="https://en.wikipedia.org/wiki/Wiener_process">Wiener process</a> (i.e., standard Brownian motion).</li>
<li>The evolution is <em><strong>stochastic</strong></em>, involving both learned dynamics and noise.</li>
</ul>
<h3 id="constructing-the-training-target-for-flow-models">Constructing the Training Target for Flow Models<a hidden class="anchor" aria-hidden="true" href="#constructing-the-training-target-for-flow-models">#</a></h3>
<p>Typically, we train the model by minimizing a <strong>mean squared error</strong>:</p>
<p>$$
L(\theta) = \left| u_t^\theta(x) - u_t^{\text{target}}(x) \right|^2
$$</p>
<p>Here, $u_t^{\text{target}}(x)$ is the <strong>training target</strong> we want the model&rsquo;s prediction $u_t^\theta(x)$ to match.</p>
<p>In standard regression or classification, the training target is usually a label. But in this case, <strong>we don’t have labels</strong>. So instead, <strong>we need to derive the training target</strong> ourselves.</p>
<h3 id="conditional-probability-path">Conditional Probability Path<a hidden class="anchor" aria-hidden="true" href="#conditional-probability-path">#</a></h3>
<p><strong>Dirac Distribution:</strong></p>
<p>Let: $z \in \mathbb{R}^d, \quad \delta_z \Rightarrow X = z$
Here, $\delta_z$ is the <a href="https://en.wikipedia.org/wiki/Dirac_delta_function"><strong>Dirac distribution</strong></a>, which assigns all probability mass to the single point $z$. This implies $X$ takes the exact value $z$.</p>
<p>We define a conditional probability path $p_t(\cdot \mid z)$ such that $p_t(\cdot \mid z)$ is a distribution over $\mathbb{R}^d$ The path starts at: $p_0(\cdot \mid z) = p_{\text{init}}$ and ends at $p_1(\cdot \mid z) = \delta_z$
This means we begin from an initial distribution and evolve it into a Dirac delta centered at $z$.</p>
<p>Example : Gaussian Probability Path - An example of such a conditional path is a Gaussian with time-varying mean and variance: $\mathcal{N}(\alpha_t z,\ \beta_t^2 I_d)$. This describes a path where samples are centered around $\alpha_t z$ and the uncertainty (spread) is controlled by $\beta_t^2$.</p>
<p><img alt="Conditional Probability Path" loading="lazy" src="/images/Conditional_Probability_Path.png"></p>
<p>Note : Conditional means per single data point and marginal means across distribution of data points</p>
<h3 id="conditional-vector-field">Conditional Vector Field<a hidden class="anchor" aria-hidden="true" href="#conditional-vector-field">#</a></h3>
<p>We define a <strong>target conditional vector field</strong>:</p>
<p>$$
u_t^{\text{target}}(x \mid z), \quad \text{for } 0 \leq t \leq 1,\ x, z \in \mathbb{R}^d
$$</p>
<p>such that:
$$
X_0 \sim p_{\text{init}}, \quad \frac{d}{dt}X_t = u_t^{\text{target}}(X_t \mid z) \quad \Rightarrow \quad X_t \sim p_t(\cdot \mid z) ;\quad 0 \leq t \leq 1
$$</p>
<ul>
<li>$X$ is the variable of interest (what we want to evolve or sample).</li>
<li>$z$ is the conditioning variable.</li>
<li>The vector field $u_t^{\text{target}}(x \mid z)$ is <strong>time-dependent</strong> (indexed by $t$), and it guides the evolution of $X$ conditioned on $z$.</li>
</ul>
<p>If we start with samples from a known distribution and move them using this conditional vector field, then the distribution of the evolved particles at time $t$ will follow the conditional target distribution $X_t \sim p_t(x \mid z)$.</p>
<p>Start by sampling $X_0$ from an initial distribution $p_{\text{init}}$.
Then, evolve the samples over time using the conditional vector field $u_t^{\text{target}}(x \mid z)$ by solving the following ODE:</p>
<p>$$
\frac{dX_t}{dt} = u_t^{\text{target}}(X_t \mid z)
$$</p>
<p>As the system evolves, at any time $t$, the samples $X_t$ should follow the desired conditional probability distribution: $$ X_t \sim p_t(x \mid z) $$
<img alt="ODE" loading="lazy" src="/images/ODE.jpeg"></p>
<h3 id="marginal-probability-path">Marginal Probability Path<a hidden class="anchor" aria-hidden="true" href="#marginal-probability-path">#</a></h3>
<p>We define the <strong>marginal path</strong> $p_t$ as the marginalization over conditional distributions.</p>
<p>Given:</p>
<ul>
<li>$z \sim p_{\text{data}}$ and $X \sim p_t(\cdot \mid z)$ -&gt; then $X \sim p_t$</li>
</ul>
<p>To obtain the marginal distribution $p_t(X)$, we integrate over $z$:</p>
<p>$$
p_t(X) = \int p_t(X \mid z) \ p_{\text{data}}(z) \ dz
$$</p>
<p>We define the probability path with:</p>
<ul>
<li>$p_0 = p_{\text{init}}$ (start from noise)</li>
<li>$p_1 = p_{\text{data}}$ (end at real data)</li>
</ul>
<p>This defines a smooth transformation from <strong>noise → data</strong> over time, as illustrated in the figure with intermediate distributions $p_t$ between $t = 0$ and $t = 1$</p>
<p><img alt="Marginal Probability Path" loading="lazy" src="/images/Marginal_Probability_Path.png"></p>
<h3 id="marginal-vector-field">Marginal Vector Field<a hidden class="anchor" aria-hidden="true" href="#marginal-vector-field">#</a></h3>
<p>We can define the <strong>marginal target vector field</strong> $u_t^{\text{target}}(x)$ by averaging the conditional vector field $u_t^{\text{target}}(x \mid z)$ weighted by the joint distribution:</p>
<p>$$
u_t^{\text{target}}(x) = \int u_t^{\text{target}}(x \mid z) \cdot \frac{p_t(x \mid z) \cdot p_{\text{data}}(z)}{p_t(x)} \ dz
$$</p>
<p>This equation uses the conditional vector field and transforms it into a marginal one over x. This satisfies:
If we sample from the initial distribution and evolve using this marginal vector field:</p>
<p>$$
X_0 \sim p_{\text{init}}, \quad \frac{d}{dt} X_t = u_t^{\text{target}}(X_t)
$$</p>
<p>Then the samples $X_t$ follow the marginal distribution:</p>
<p>$$
X_t \sim p_t \quad \text{for } t \in [0, 1]
$$</p>
<p>At $t = 1$, we reach the target:</p>
<p>$$
X_1 \sim p_{\text{data}}
$$</p>
<p>This method is often referred to as the <strong>&ldquo;Marginalization Trick&rdquo;</strong>, where we compute a marginal vector field $u_t^{\text{target}}(x)$ given the conditional one $u_t^{\text{target}}(x \mid z)$.</p>
<p><img alt="Probability_Paths" loading="lazy" src="/images/Comparison_of_Probability_Paths.png"></p>
<h3 id="conditional--marginal-score-function">Conditional &amp; Marginal Score Function<a hidden class="anchor" aria-hidden="true" href="#conditional--marginal-score-function">#</a></h3>
<p>In generative modeling, a <strong>score function</strong> refers to the gradient of the log-probability with respect to the input. It points in the direction where the data density increases—useful for guiding the sampling process.</p>
<h4 id="1-conditional-score">1. Conditional Score<a hidden class="anchor" aria-hidden="true" href="#1-conditional-score">#</a></h4>
<p>$$
\nabla_x \log p_t(x \mid z)
$$
Represents the gradient of the log-density of $x$ <strong>given</strong> a conditioning variable $z$. It tells us how likely $x$ is, assuming we already know $z$.</p>
<h4 id="2-marginal-score">2. Marginal Score<a hidden class="anchor" aria-hidden="true" href="#2-marginal-score">#</a></h4>
<p>$$
\nabla_x \log p_t(x)
$$
Represents the gradient of the <strong>marginal</strong> log-density of $x$, where $z$ is integrated out. It is used in <strong>unconditional models</strong> that learn the overall data distribution without conditioning. Central to score-based diffusion models and other likelihood-free approaches.</p>
<h2 id="flow-matching">Flow Matching<a hidden class="anchor" aria-hidden="true" href="#flow-matching">#</a></h2>
<p>Now that we&rsquo;ve covered the core ideas behind flow models—like what a flow is, how normalizing flows work, and the roles of conditional and marginal probability paths and vector fields—let&rsquo;s dive into what <strong>Flow Matching</strong> actually is.</p>
<p>The goal of <strong>Flow Matching</strong> is to learn a neural vector field $u_t^\theta$ that closely matches the target vector field $u_t^{\text{target}}$:</p>
<p>$$
u_t^\theta \approx u_t^{\text{target}}
$$</p>
<h3 id="flow-matching-loss">Flow Matching Loss<a hidden class="anchor" aria-hidden="true" href="#flow-matching-loss">#</a></h3>
<p>The objective in flow matching is to minimize the difference between the learned vector field $u_t^\theta(x)$ and the target vector field $u_t^{\text{target}}(x)$. The ideal loss function is:</p>
<p>$$
\mathcal{L}_{\text{fm}}(\theta) = \mathbb{E} \left[ \left| u_t^\theta(x) - u_t^{\text{target}}(x) \right|^2 \right]
$$</p>
<p>To evaluate this loss (in theory), we would:</p>
<ul>
<li>Sample $t \sim \text{Uniform}[0, 1]$</li>
<li>Sample $z \sim p_{\text{data}}$ (a real data point)</li>
<li>Sample $x \sim p_t(\cdot \mid z)$ from the conditional path</li>
</ul>
<p>The challenge is that we <strong>cannot directly compute</strong> this loss, because the true target vector field $u_t^{\text{target}}(x)$ is unknown or intractable. So what&rsquo;s the solution? Conditional Flow Matching Loss!</p>
<h3 id="conditional-flow-matching-loss">Conditional Flow Matching Loss<a hidden class="anchor" aria-hidden="true" href="#conditional-flow-matching-loss">#</a></h3>
<p>We define the <strong>Conditional Flow Matching (CFM) loss</strong> as:</p>
<p>$$
\mathcal{L}_{\text{cfm}}(\theta) = \mathbb{E} \left[ \left| u_t^\theta(x) - u_t^{\text{target}}(x \mid z) \right|^2 \right]
$$</p>
<p>Where:</p>
<ul>
<li>$t \sim \text{Uniform}[0, 1]$</li>
<li>$z \sim p_{\text{data}}$ (draw a data sample)</li>
<li>$x \sim p_t(\cdot \mid z)$ (draw from conditional probability path)</li>
</ul>
<p><strong>Theorem</strong>:</p>
<p>There exists a constant $c &gt; 0$ (independent of $\theta$) such that:</p>
<p>$$
L_{\text{fm}}(\theta) = L_{\text{cfm}}(\theta) + c
$$</p>
<p>This means minimizing the <strong>conditional loss</strong> is equivalent (up to a constant) to minimizing the original flow matching loss.</p>
<p><img alt="Theorem" loading="lazy" src="/images/Graph_of_Conditional_Flow_Matching_and_Flow_Matching.jpeg"></p>
<h3 id="key-consequences">Key Consequences<a hidden class="anchor" aria-hidden="true" href="#key-consequences">#</a></h3>
<ol>
<li>The minimizer $\theta^*$ of $\mathcal{L}_{\text{cfm}}$ satisfies:</li>
</ol>
<p>$$
u_t^{\theta^*} = u_t^{\text{target}}
$$</p>
<ol start="2">
<li>The gradients are the same:</li>
</ol>
<p>$$
\nabla_\theta L_{\text{cfm}}(\theta) = \nabla_\theta L_{\text{fm}}(\theta)
$$</p>
<p>So <a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">**Stochastic Gradient Descent</a> (SGD)** behaves the same for both losses and the <strong>training trajectories will not differ</strong>.
All we need to do is minimize a simple <strong>mean squared error</strong> loss, which is much easier to optimize than adversarial objectives like those in GANs (which require <a href="https://deepgenerativemodels.github.io/notes/gan/">min-max optimization</a>).</p>
<h3 id="flow-matching-training-procedure-general">Flow Matching Training Procedure (General)<a hidden class="anchor" aria-hidden="true" href="#flow-matching-training-procedure-general">#</a></h3>
<p><strong>Given:</strong></p>
<ul>
<li>A dataset of samples $z \sim p_{\text{data}}$</li>
<li>A neural network $u_t^\theta$ (the learnable vector field)</li>
</ul>
<p><strong>Training Loop</strong></p>
<p><strong>For each mini-batch of data:</strong></p>
<ol>
<li>Sample a data example $z$ from the dataset.</li>
<li>Sample a random time $t \sim \text{Uniform}[0, 1]$.</li>
<li>Sample $x \sim p_t(\cdot \mid z)$ — from the conditional path at time $t$.</li>
<li>Compute the flow matching loss:
$$
\mathcal{L}(\theta) = \left| u_t^\theta(x) - u_t^{\text{target}}(x \mid z) \right|^2
$$</li>
<li>Update model parameters $\theta$ using gradient descent on $\mathcal{L}(\theta)$.</li>
</ol>
<h3 id="flow-matching-training-for-condot-optimal-transport-path">Flow Matching Training for <a href="https://math.nyu.edu/~tabak/publications/Tabak_Trigila_Zhao_COT.pdf">CondOT</a> (Optimal Transport) Path<a hidden class="anchor" aria-hidden="true" href="#flow-matching-training-for-condot-optimal-transport-path">#</a></h3>
<p><strong>Given:</strong></p>
<ul>
<li>A dataset of samples $z \sim p_{\text{data}}$</li>
<li>A neural network vector field $u_t^\theta$</li>
</ul>
<p><strong>Training Procedure</strong></p>
<p><strong>For each mini-batch:</strong></p>
<ol>
<li>Sample a data example $z$ from the dataset.</li>
<li>Sample a random time $t \sim \text{Uniform}[0, 1]$.</li>
<li>Sample noise $\epsilon \sim \mathcal{N}(0, I_d)$.</li>
<li>Compute:
$$
x = t z + (1 - t) \epsilon
$$</li>
<li>Compute the loss:
$$
\mathcal{L}(\theta) = \left| u_t^\theta(x) - (z - \epsilon) \right|^2
$$</li>
<li>Update model parameters $\theta$ via gradient descent on $\mathcal{L}(\theta)$.</li>
</ol>
<p><img alt="CondOT" loading="lazy" src="/images/CondOT.png"></p>
<h2 id="rectified-flows">Rectified Flows<a hidden class="anchor" aria-hidden="true" href="#rectified-flows">#</a></h2>
<p>Since distributions are at the heart of statistics and machine learning, many core problems—like generative modeling and domain transfer—can be understood through the lens of finding a transport map that moves one distribution to another. <a href="https://arxiv.org/abs/2209.03003"><strong>Rectified Flow</strong></a> offers a simple way to do this by learning an ordinary differential equation (ODE), also known as a flow model, with the central idea of encouraging movement along straight paths as much as possible. This approach is closely connected to neural ODEs and stochastic differential equation (SDE) models, particularly the widely used diffusion generative models and their ODE variants.</p>
<p>Traditionally, there are infinitely many ODEs or SDEs that could map between two distributions, and most methods implicitly choose a trajectory without a clear principle. In contrast, rectified flow <strong>explicitly</strong> prefers ODEs whose solution paths are straight lines—what they call <em>straight flows</em>. This leads to a simple, principled framework that ties naturally to optimal transport theory. A major advantage is that straight flows eliminate discretization error when solving ODEs numerically, meaning rectified flows allow very fast inference—sometimes achievable in just a single Euler step. As a result, they combine the <strong>speed</strong> of one-step generative models like GANs and VAEs with the <strong>robustness</strong> and <strong>training stability</strong> of multi-step ODE/SDE-based models.</p>
<h3 id="learning-transport-maps">Learning Transport Maps<a hidden class="anchor" aria-hidden="true" href="#learning-transport-maps">#</a></h3>
<p><strong>The Transport Mapping Problem</strong>:</p>
<p>Given empirical observations of two distributions $\pi_0, \pi_1$ on $\mathbb{R}^d$,<br>
the goal is to find a transport map:</p>
<p>$$
T: \mathbb{R}^d \to \mathbb{R}^d
$$</p>
<p>such that, in the infinite data limit, $Z_1 := T(Z_0) \sim \pi_1$ when $Z_0 \sim \pi_0$.<br>
In other words, $(Z_0, Z_1)$ forms a coupling (also called a transport plan) between $\pi_0$ and $\pi_1$.</p>
<ul>
<li>
<p><strong>Generative Modeling:</strong></p>
<ul>
<li>$\pi_1$ is an unknown data distribution (e.g., images),</li>
<li>$\pi_0$ is a simple known distribution (e.g., standard Gaussian).</li>
<li>The goal is to learn a nonlinear transform that maps samples from $\pi_0$ to samples from $\pi_1$.</li>
</ul>
</li>
<li>
<p><strong>Transfer Modeling:</strong></p>
<ul>
<li>Both $\pi_0$ and $\pi_1$ are unknown empirical distributions.</li>
<li>The goal is to transfer data points from $\pi_0$ to $\pi_1$, or vice versa.</li>
<li>Applications include domain adaptation, transfer learning, image editing, and sim2real in robotics.</li>
</ul>
</li>
</ul>
<h3 id="why-is-finding-a-transport-map-challenging">Why is Finding a Transport Map Challenging?<a hidden class="anchor" aria-hidden="true" href="#why-is-finding-a-transport-map-challenging">#</a></h3>
<p>Given two distributions, there are <strong>infinitely many</strong> possible transport maps $T$.<br>
The goal is to find one that transfers $\pi_0$ to $\pi_1$ and has desirable properties, such as <strong>high computational efficiency</strong> and <strong>practical simplicity</strong></p>
<p>To achieve this, we often formulate the problem mathematically to impose additional desirable properties.</p>
<h3 id="optimal-transport-ot">Optimal Transport (OT)<a hidden class="anchor" aria-hidden="true" href="#optimal-transport-ot">#</a></h3>
<p>One canonical formulation is <strong>Optimal Transport (OT)</strong>, where we seek a transport plan that minimizes a <strong>cost</strong>.</p>
<p>Specifically, <a href="https://en.wikipedia.org/wiki/Transportation_theory_(mathematics)">Monge&rsquo;s Optimal Transport</a> problem is:</p>
<p>$$
\min_T \mathbb{E} \left[ c(T(Z_0) - Z_0) \right] \quad \text{subject to} \quad \text{Law}(Z_0) = \pi_0, \quad \text{Law}(T(Z_0)) = \pi_1
$$
where:</p>
<ul>
<li>$c: \mathbb{R}^d \to \mathbb{R}$ is a cost function (e.g., $c(x) = \frac{1}{2} |x|^2$),</li>
<li>$\mathbb{E}\left[ c(T(Z_0) - Z_0) \right]$ measures the expected transport cost.</li>
</ul>
<p>Think of $Z_0$ and $Z_1$ as two piles of sand, and $c(Z_1 - Z_0)$ as the cost of moving sand from $Z_0$ to $Z_1$.</p>
<p>However, solving the optimal transport (OT) problem remains highly challenging, especially when dealing with high-dimensional data and large-scale datasets. Developing efficient algorithms for these settings is still an open problem.</p>
<p>Moreover, in generative and transfer modeling, the transport cost itself is often not the primary focus — the learning performance is not directly tied to the magnitude of $Z_1 - Z_0$. While optimal transport maps do induce smoothness properties that are beneficial for learning, minimizing transport cost isn&rsquo;t the ultimate goal.</p>
<p><img alt="Trajectory" loading="lazy" src="/images/Diffusion_Trajectory_Optimal_Transport.png"></p>
<h3 id="method-rectified-flow">Method: Rectified Flow<a hidden class="anchor" aria-hidden="true" href="#method-rectified-flow">#</a></h3>
<p>Rectified flow learns the transport map $T$ <strong>implicitly</strong> by constructing an<br>
<strong>ordinary differential equation (ODE)</strong> driven by a drift force:</p>
<p>$$
dZ_t = v(Z_t, t) dt, \quad t \in [0, 1], \quad \text{starting from} \quad Z_0 \sim \pi_0
$$</p>
<p>The goal is to ensure that when we follow the ODE starting from $Z_0 \sim \pi_0$,<br>
we end up with $Z_1 \sim \pi_1$.</p>
<p>The main challenge is how to construct the drift field $v$ based only on observations from $\pi_0$and $\pi_1$, typically using deep neural networks or other nonlinear approximators.</p>
<p>At first glance, this looks hard. One natural idea is to find $v$ by minimizing a discrepancy measure $D(\rho_1^v, \pi_1)$, where $\rho_1^v$ is the distribution of $Z_1$ after following the ODE driven by $v$ and $D(\cdot, \cdot)$ is some divergence, like <a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">KL divergence</a>.</p>
<p>However, this requires:</p>
<ul>
<li>Repeated simulation of the ODE,</li>
<li>Inferring intermediate states, which is <strong>computationally expensive</strong>,</li>
<li>And the big problem: <strong>we don&rsquo;t know</strong> what intermediate trajectories the ODE should travel through!</li>
</ul>
<p>We can avoid these difficulties by <strong>exploiting the over-parameterized nature</strong> of the problem. Since we only care about matching the <strong>start</strong> ($\pi_0$) and <strong>end</strong> ($\pi_1$) distributions,<br>
the intermediate states $\pi_t$ of $Z_t$ can be <strong>any smooth interpolation</strong> between $\pi_0$ and $\pi_1$.
Thus, we can (and should) <strong>inject strong assumptions</strong> about the intermediate paths.<br>
The simplest and most effective assumption? <strong>Straight trajectories</strong>.</p>
<h3 id="why-straight-paths">Why Straight Paths?<a hidden class="anchor" aria-hidden="true" href="#why-straight-paths">#</a></h3>
<ul>
<li><strong>Theoretically:</strong> They align well with ideas from optimal transport.</li>
<li><strong>Computationally:</strong> ODEs following straight paths have <strong>zero discretization error</strong>,<br>
meaning they can be solved exactly or with very few numerical steps.</li>
</ul>
<p><img alt="Interpolation and Rectified Flow" loading="lazy" src="/images/Linear_Interpolation_Rectified_Flow.png"></p>
<h3 id="how-rectified-flow-works">How Rectified Flow Works<a hidden class="anchor" aria-hidden="true" href="#how-rectified-flow-works">#</a></h3>
<p>Specifically, rectified flow works by <strong>finding an ODE to match the marginal distributions</strong> of the <strong>linear interpolation of points</strong> between $\pi_0$ and $\pi_1$.</p>
<p>Assume we observe $X_0 \sim \pi_0$ and $X_1 \sim \pi_1$. Let $X_t$ for all $t \in [0,1]$ be the linear (geodesic) interpolation between $X_0$ and $X_1$:</p>
<p>$$
X_t = t X_1 + (1 - t) X_0
$$</p>
<p>Observe that $X_t$ follows a simple ODE that already transfers $\pi_0$ to $\pi_1$:</p>
<p>$$
dX_t = (X_1 - X_0)dt
$$</p>
<p>This means that $X_t$ moves along the line direction $(X_1 - X_0)$ at a constant speed.
However, this ODE is <strong>non-causal</strong>:</p>
<ul>
<li>The update $X_t$ depends on the final state $X_1$, which is <strong>unknown</strong> at time $t &lt; 1$.</li>
<li>When multiple trajectories cross at a point $X_t$, the direction of motion becomes ambiguous and non-unique.</li>
<li>Thus, the &ldquo;causal ODE&rdquo; needed for simulation cannot just be the naive ODE in the equation above.</li>
</ul>
<h3 id="solution-causalizing-the-interpolation">Solution: Causalizing the Interpolation<a hidden class="anchor" aria-hidden="true" href="#solution-causalizing-the-interpolation">#</a></h3>
<p>We want to &ldquo;<strong>causalize</strong>&rdquo; the interpolation process $X_t$ by projecting it into the space of causally simulatable ODEs:</p>
<p>$$
dZ_t = v(Z_t, t) dt
$$</p>
<p>A natural way to do this is to <strong>project</strong> the velocity field onto a causal one by minimizing an L2 loss:</p>
<p>$$
\min_v \int_0^1 \mathbb{E} \left[ | (X_1 - X_0) - v(X_t, t) |^2 \right] dt
$$</p>
<p>This finds a drift $v$ that approximates the ideal direction $(X_1 - X_0)$ as closely as possible at each point $(X_t, t)$.</p>
<p><strong>Theoretical Solution: Conditional Expectation</strong></p>
<p>The optimal drift $v(z,t)$ can be written as:</p>
<p>$$
v(z, t) = \mathbb{E}[X_1 - X_0 \mid X_t = z]
$$</p>
<p>This means $v(z,t)$ is the <strong>expected direction</strong> of the lines passing through the point $z$ at time $t$. We call the ODE with this $v(z,t)$ the <strong>rectified flow</strong> induced from $(X_0, X_1)$.</p>
<p><strong>In practice:</strong></p>
<ul>
<li>We solve the minimization using standard optimizers like SGD.</li>
<li>We parameterize $v$ with a neural network or other function approximator.</li>
<li>The conditional expectation $\mathbb{E}[\cdot]$ is estimated empirically from samples $(X_0, X_1)$.</li>
</ul>
<p>The <strong>trajectories $Z_t$</strong> traced by rectified flow follow the <strong>same density path</strong> as the original interpolation $X_t$,<br>
but they <strong>rewire</strong> themselves at intersections to maintain causality and avoid non-uniqueness.</p>
<h3 id="key-properties-of-rectified-flow">Key Properties of Rectified Flow<a hidden class="anchor" aria-hidden="true" href="#key-properties-of-rectified-flow">#</a></h3>
<ol>
<li>The ODE trajectories $Z_t$ and the interpolation $X_t$ have the <strong>same marginal distributions</strong> for all $t \in [0, 1]$:</li>
</ol>
<p>$$
\text{Law}(Z_t) = \text{Law}(X_t), \quad \forall t \in [0, 1].
$$</p>
<p>Thus, $(Z_0, Z_1)$ forms a valid <strong>coupling</strong> of the distributions $\pi_0$ and $\pi_1$.</p>
<ol start="2">
<li>The coupling $(Z_0, Z_1)$ also guarantees <strong>no larger transport cost</strong> compared to $(X_0, X_1)$  for <strong>any convex cost function</strong> $c : \mathbb{R}^d \to \mathbb{R}$:</li>
</ol>
<p>$$
\mathbb{E} \left[ c(Z_1 - Z_0) \right] \leq \mathbb{E} \left[ c(X_1 - X_0) \right], \quad \forall \text{ convex } c.
$$</p>
<ul>
<li>The data pair $(X_0, X_1)$ can be an arbitrary (possibly independent) coupling of $\pi_0$ and $\pi_1$</li>
<li>Typically, $(X_0, X_1) \sim \pi_0 \times \pi_1$ is sampled independently from $\pi_0$ and $\pi_1$.</li>
<li>In contrast, the rectified coupling $(Z_0, Z_1)$ introduces a <strong>deterministic dependency</strong> because it is induced from an ODE flow.</li>
</ul>
<p>Thus, <strong>rectified flow converts an arbitrary coupling into a deterministic coupling, without increasing convex transport costs</strong>.</p>
<h3 id="reflow-fast-generation-with-straight-flows">Reflow: Fast Generation with Straight Flows<a hidden class="anchor" aria-hidden="true" href="#reflow-fast-generation-with-straight-flows">#</a></h3>
<p>Denote the rectified flow $Z = { Z_t : t \in [0, 1] }$ induced from $(X_0, X_1)$ by:</p>
<p>$$
Z = \text{Rectflow}((X_0, X_1)).
$$</p>
<p>Applying the $\text{Rectflow}(\cdot)$ operator recursively yields a sequence of rectified flows:</p>
<p>$$
Z^{k+1} = \text{Rectflow}((Z_0^k, Z_1^k)),
$$</p>
<p>where $(Z_0^0, Z_1^0) = (X_0, X_1)$. Here, $Z^k$ is the $k$-th rectified flow, induced from $(X_0, X_1)$.</p>
<p>In practice:</p>
<ul>
<li>We sample $(Z_0^k, Z_1^k)$ from the current $k$-th rectified flow,</li>
<li>Then retrain a new rectified flow from these samples,</li>
<li>Each step makes the flow paths <strong>straighter</strong>.</li>
</ul>
<p><strong>Why This Matters?</strong></p>
<p>Besides lowering transport cost, this &ldquo;<strong>reflow</strong>&rdquo; process has an important side effect:</p>
<ul>
<li>It <strong>straightens</strong> the paths of rectified flows.</li>
<li>As $k$ increases, the paths of $Z^k$ become increasingly straight.</li>
</ul>
<h3 id="key-properties">Key Properties<a hidden class="anchor" aria-hidden="true" href="#key-properties">#</a></h3>
<p>The <strong>straightness</strong> of a flow $Z$ can be measured by:</p>
<p>$$
s(Z) = \int_0^1 \mathbb{E} \left[ | Z_1 - Z_0 - v(Z_t, t) |^2 \right] dt,
$$
where:</p>
<ul>
<li>$S(Z) = 0$ corresponds to <strong>perfectly straight</strong> paths.</li>
<li>After $k$ iterations, we have:</li>
</ul>
<p>$$
\min_{k \leq K} S(Z^k) = O(1/K).
$$
<strong>Computational Advantage</strong>:
Flows with nearly straight paths are <strong>computationally efficient</strong>:</p>
<ul>
<li>They have <strong>minimal discretization error</strong>.</li>
<li>If the ODE $dZ_t = v(Z_t, t) dt$ has straight paths, then:</li>
</ul>
<p>$$
Z_t = Z_0 + t v(Z_0, 0),
$$</p>
<p>Meaning: the ODE can be solved exactly with just a <strong>single Euler step</strong>!</p>
<p>This addresses the <strong>slow inference bottleneck</strong> of traditional ODE/SDE models.
Thus, <strong>reflow</strong> enables training <strong>one-step generative models</strong> (like GANs or VAEs) using ODE flows.</p>
<p><img alt="Reflow" loading="lazy" src="/images/Reflow.png"></p>
<p><img alt="Rectified Flow" loading="lazy" src="/images/Rectified_Flow.png"></p>
<p>In this blog, we took a deep dive into the world of flows — exploring what a flow is, understanding normalizing flows, learning about flow matching, and diving into conditional and marginal probability paths and vector fields. We also unpacked rectified flows in detail. Altogether, this has helped us build a strong theoretical foundation and intuition around flows. In the next blog, we&rsquo;ll shift gears and explore different flow-based models and their architectures.</p>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ol>
<li><a href="https://arxiv.org/abs/2412.06264">Flow Matching Guide and Code</a>- <em>Y. Lipman</em></li>
<li><a href="https://arxiv.org/abs/2210.02747">Flow Matching for Generative Modeling</a> - <em>Y. Lipman</em></li>
<li><a href="https://arxiv.org/abs/1908.09257">Normalizing Flows: An Introduction and Review of Current Methods</a> - <em>Ivan Kobyzev</em></li>
<li><a href="https://arxiv.org/abs/2209.03003">Flow Straight and Fast: Learning to Generate and Transfer Data with Rectified Flow</a> - Xingchao Liu</li>
<li><a href="https://arxiv.org/abs/2403.03206">Scaling Rectified Flow Transformers for High-Resolution Image Synthesis</a> - <em>Patrick Esser</em> - <em>Stability AI</em></li>
<li><a href="https://lilianweng.github.io/posts/2018-10-13-flow-models/">Flow-based Deep Generative Models</a> - <em>Lilian Weng</em></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/image-generation/">Image Generation</a></li>
      <li><a href="http://localhost:1313/tags/flow-matching/">Flow Matching</a></li>
      <li><a href="http://localhost:1313/tags/normalizing-flows/">Normalizing Flows</a></li>
      <li><a href="http://localhost:1313/tags/rectified-flows/">Rectified Flows</a></li>
      <li><a href="http://localhost:1313/tags/stable-diffusion/">Stable Diffusion</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">yadnyesh&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
